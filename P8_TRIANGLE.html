<hr>
<p><strong>TRIANGLE</strong></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="16889" data-permalink="https://karlinaobject.wordpress.com/triangle_image/" data-orig-file="https://karlinaobject.files.wordpress.com/2022/07/triangle_image.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="triangle_image" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.files.wordpress.com/2022/07/triangle_image.png?w=300" data-large-file="https://karlinaobject.files.wordpress.com/2022/07/triangle_image.png?w=960" src="https://karlinaobject.files.wordpress.com/2022/07/triangle_image.png" alt="" class="wp-image-16889" /></figure>


<hr>
<p>Portable-Network-Graphics_image_link: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_image.png" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_image.png</a></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="16887" data-permalink="https://karlinaobject.wordpress.com/points_on_cartesian_grid/" data-orig-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="points_on_cartesian_grid" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png?w=300" data-large-file="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png?w=960" src="https://karlinaobject.files.wordpress.com/2022/07/points_on_cartesian_grid.png" alt="" class="wp-image-16887" /></figure>


<hr />
<p>Portable-Network-Graphics_image_link: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/points_on_cartesian_grid.png" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/points_on_cartesian_grid.png</a></p>
<hr />
<p><span style="background:#ffff00;">The <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> program featured in this tutorial web page demonstrates the concept of Object Oriented Programming (<a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">OOP</a>). The program implements a user defined data type for instantiating <strong>TRIANGLE</strong> type objects. Each TRIANGLE type object represents three instances of the <a style="background:#000000;color:#00ff00;" href="https://karlinaobject.wordpress.com/point/" target="_blank" rel="noopener">POINT</a> class named <strong>A</strong>, <strong>B</strong>, and <strong>C</strong> which each represent a unique whole number coordinate pair. A TRIANGLE object can execute various functions including the ability to compute the <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/Area" target="_blank" rel="noopener">area</a> of the two-dimensional region whose boundaries are the line segments which connect the points which the three POINT type variables of the TRIANGLE object represent and the ability to compute the interior <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/Angle" target="_blank" rel="noopener">angle</a> measurement of any one of the three interior angles of the triangle which the TRIANGLE object represents.</span></p>
<p><span style="background:#00ff00;">To view hidden text inside of the preformatted text boxes below, scroll horizontally.</span></p>
<pre>class : object :: data_type : variable.</pre>
<hr />
<p><strong>SOFTWARE_APPLICATION_COMPONENTS</strong></p>
<hr />
<p>C++_header_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.h</a></p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.cpp</a></p>
<p>C++_header_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.h</a></p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.cpp</a></p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester.cpp</a></p>
<p>plain-text_file: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester_output.txt" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester_output.txt</a></p>
<hr />
<p><strong>PROGRAM_COMPILATION_AND_EXECUTION</strong></p>
<hr />
<p>STEP_0: Copy and paste the C++ code from the files named <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.h" target="_blank" rel="noopener">point.h</a>, <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.cpp" target="_blank" rel="noopener">point.cpp</a>, <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.h" target="_blank" rel="noopener">triangle.h</a>, <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.cpp" target="_blank" rel="noopener">triangle.cpp</a>, and <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester.cpp" target="_blank" rel="noopener">triangle_class_tester.cpp</a> into their own new text editor documents and save those documents using their corresponding file names:</p>
<pre>point.h</pre>
<pre>point.cpp</pre>
<pre>triangle.h</pre>
<pre>triangle.cpp</pre>
<pre>triangle_class_tester.cpp</pre>
<p>STEP_1: Open a <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a> command line terminal application and set the current directory to wherever the C++ is located on the local machine (e.g. Desktop).</p>
<pre>cd Desktop</pre>
<p>STEP_2: Compile the C++ file into machine-executable instructions (i.e. object file) and then into an executable piece of software named <strong>app</strong> using the following command:</p>
<pre>g++ triangle_class_tester.cpp triangle.cpp point.cpp -o app</pre>
<p>STEP_3: If the program compilation command does not work, then use the following command to install the C++ compiler:</p>
<pre>sudo apt install build-essential</pre>
<p>STEP_4: Observe program results on the command line terminal and in the <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester_output.txt" target="_blank" rel="noopener">output file</a>.</p>
<hr />
<p><strong>POINT_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the POINT class.</p>
<p><span style="background:#00ff00;">When copy-pasting the source code from the preformatted text box below into a text editor document, remove the spaces between the angle brackets and the library names in the preprocessing directives code block. (The spaces were inserted between the library names and angle brackets in the preformatted text box below in order to prevent the WordPress server from misinterpreting those C++ library references as <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a> tags in the source code of this web page).</span></p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.h</a></p>
<hr />
<pre>/**
 * file: point.h
 * type: C++ (header file)
 * author: Karlina Ray Beringer
 * date: 19_NOVEMBER_2022
 * license: PUBLIC_DOMAIN
 */

/* preprocessing directives */
#ifndef POINT_H // If point.h has not already been linked to a source file (.cpp), 
#define POINT_H // then link this header file to the source file(s) which include this header file.

/* preprocessing directives */
#include &lt; iostream &gt; // library for defining objects which handle command line input and command line output
#include &lt; fstream &gt; // library for defining objects which handle file input and file output
#include &lt; cmath &gt; // library which defines the square root function (sqrt()), trigonometric functions (e.g. sine (sin()), cosine (cos()), tangent (tan())), and the floor function (which rounds the input number down to that number's nearest integer)
#include &lt; string &gt; // library which defines a sequence of text characters (i.e. char type values) as a string type variable
#define MINIMUM_X -999 // constant which represents minimum X value
#define MAXIMUM_X 999 // constant which represents maximum X value
#define MINIMUM_Y -999 // constant which represents minimum Y value
#define MAXIMUM_Y 999 // constant which represents maximum Y value
#define PI 3.14159 // constant which represents the approximate value of a circle's circumference divided by that circle's diameter

/**
 * Define a class which is used to instantiate POINT type objects.
 * 
 * (An object is a variable whose data type is user defined rather than native to the C++ programming language).
 * 
 * A POINT object represents a whole number coordinate pair in the form (X,Y).
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of the same two-dimensional Cartesian grid.
 * 
 * X stores one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * Y stores one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 */
class POINT
{
private:
    int X, Y; // data attributes
public:
    POINT(); // default constructor
    POINT(int X, int Y); // normal constructor
    POINT(const POINT &amp; point); // copy constructor
    int get_X(); // getter method
    int get_Y(); // getter method
    bool set_X(int X); // setter method
    bool set_Y(int Y); // setter method
    double get_distance_from(POINT &amp; point); // getter method
    double get_slope_of_line_to(POINT &amp; point); // getter method
    void print(std::ostream &amp; output = std::cout); // descriptor method
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point); // descriptor method
    ~POINT(); // destructor
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>POINT_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the POINT class.</p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/point.cpp</a></p>
<hr />
<pre>/**
 * file: point.cpp
 * type: C++ (source file)
 * date: 19_NOVEMBER_2022
 * author: Karlina Ray Beringer
 * license: PUBLIC_DOMAIN 
 */

/* preprocessing directives */
#include "point.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.

/**
 * The default constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is initially set to 0 and 
 * whose Y value is initially set to 0.
 * 
 * The default constructor method of the POINT class is invoked 
 * when a POINT type variable is declared as follows:
 * 
 * // variable declaration example one
 * POINT point_0; 
 * 
 * // variable declaration example two
 * POINT point_1 = POINT();
 */
POINT::POINT()
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = 0;
    Y = 0;
}

/**
 * The normal constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is set to the leftmost function input value (if that input value is no smaller than MINIMUM_X and no larger than MAXIMUM_X) and 
 * whose Y value is set to the rightmost function input value (if that input value is no smaller than MINIMUM_Y and no larger than MAXIMUM_Y).
 * 
 * If a function input value is out of its specified range, then set the corresponding int type property of this to 0.
 * 
 * (The keyword this refers to the POINT object which is returned by this function).
 *
 * The normal constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // variable definition example one
 * POINT point_0 = POINT(-55,84);
 * 
 * // variable definition example two
 * POINT point_1 = POINT(3,-4);
 * 
 * // variable definition example three
 * POINT point_2 = POINT(-1000, 999); // point_2 = POINT(0,999).
 * 
 * // variable definition example four
 * POINT point_3 = POINT(1000,-999); // point_3 = POINT(0,-999).
 * 
 * // variable definition example five
 * POINT point_4 = POINT(999,-1000); // point_4 = POINT(999,0).
 * 
 * // variable definition example six
 * POINT point_5 = POINT(-999,1000); // point_5 = POINT(-999,0).
 */
POINT::POINT(int X, int Y)
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    this -&gt; X = ((X &lt; MINIMUM_X) || (X &gt; MAXIMUM_X)) ? 0 : X; // Set the X property of the POINT instance being created to 0 if the function input X value is out of range.
    this -&gt; Y = ((Y &lt; MINIMUM_Y) || (Y &gt; MAXIMUM_Y)) ? 0 : Y; // Set the Y property of the POINT instance being created to 0 if the function input Y value is out of range.
}

/**
 * The copy constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is set to the X value of the input POINT object and 
 * whose Y value is set to the Y value of the input POINT object.
 *
 * The copy constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // variable definition example one
 * POINT point_0 = POINT(33,55);
 * POINT point_1 = POINT(point_0); // point_1 = POINT(33,55).
 * 
 * // variable definition example two
 * POINT point_2 = POINT(point_1); // point_2 = POINT(33,55).
 */
POINT::POINT(const POINT &amp; point) 
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = point.X;
    Y = point.Y;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's X property.
 * 
 * X is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 */
int POINT::get_X()
{
    return X;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's Y property.
 * 
 * Y is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 * 
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of a two-dimensional Cartesian grid.
 */
int POINT::get_Y()
{
    return Y;
}

/**
 * The setter method of the POINT class sets the POINT object's X property to the function input value 
 * if that value is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * 
 * If the input value is in range, then return true. 
 * Otherwise, do not change the caller POINT object's X value and return false.
 * 
 * (The keyword this refers to the POINT object which calls this function).
 * 
 * (X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid).
 */
bool POINT::set_X(int X)
{
    if ((X &gt;= MINIMUM_X) &amp;&amp; (X &lt;= MAXIMUM_X)) 
    {
        this -&gt; X = X;
        return true;
    }
    return false;
}

/**
 * The setter method of the POINT class sets the POINT object's Y property to the function input value 
 * if that value is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 * 
 * If the input value is in range, then return true. 
 * Otherwise, do not change the caller POINT object's Y value and return false.
 * 
 * (The keyword this refers to the POINT object which calls this function).
 * 
 * (Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of a two-dimensional Cartesian grid).
 */
bool POINT::set_Y(int Y)
{
    if ((Y &gt;= MINIMUM_Y) &amp;&amp; (Y &lt;= MAXIMUM_Y)) 
    {
        this -&gt; Y = Y;
        return true;
    }
    return false;
}

/**
 * The getter method of the POINT class returns the length of the shortest path 
 * between the two-dimensional point represented by the the caller POINT object (i.e. this) 
 * and the two-dimensional point represented by the input POINT object (i.e. point).
 * 
 * Use the Pythagorean Theorem to compute the length of a right triangle's hypotenuse 
 * such that the two end points of that hypotenuse are represented by this and point.
 * 
 * (A hypotenuse is the only side of a right triangle which does not form a right angle 
 * with any other side of that triangle).
 * 
 * (A hypotenuse is the longest side of a triangle (and a triangle is a three-sided polygon 
 * in which three unique line segments connect three unique points)).
 * 
 * // c is the length of a right triangle's hypotenuse.
 * // a is the length of that right triangle's horizontal leg.
 * // b is the length of that triangle's vertical leg.
 * (c * c) = (a * a) + (b * b). 
 * 
 * // sqrt() is a native C++ function defined in the cmath library.
 * c = square_root( (a * a) + (b * b)). 
 */
double POINT::get_distance_from(POINT &amp; point)
{
    int horizontal_difference = 0.0, vertical_difference = 0.0;
    horizontal_difference = X - point.X; // a
    vertical_difference = Y - point.Y; // b
    return sqrt((horizontal_difference * horizontal_difference) + (vertical_difference * vertical_difference)); // c
}

/**
 * The getter method of the POINT class returns the slope of the line which intersects 
 * the two-dimensional point represented by the caller POINT instance (i.e. this)
 * and the two-dimensional point represented by the input POINT instance (i.e. point).
 * 
 * // y := f(x), 
 * // b := f(0), 
 * // f is a function whose input is an x-axis position and whose output is a y-axis position.
 * y := mx + b.
 * 
 * // m is a constant which represents the rate at which y changes in relation to x changing.
 * m := (y - b) / x. 
 * 
 * // m represents the difference of the two y-values divided by the difference of the two x-values.
 * m := (point.Y - this.Y) / (point.X - this.X).
 */
double POINT::get_slope_of_line_to(POINT &amp; point)
{
    double vertical_difference = 0.0, horizontal_difference = 0.0, result = 0.0;
    vertical_difference = point.Y - Y;
    horizontal_difference = point.X - X;
    result = vertical_difference / horizontal_difference;
    if (result == -0) result = 0; // Signed zeros sometimes occur inside of C++ program runtime instances.
    return result;
}

/**
 * The print method of the POINT class prints a description of the caller POINT object to the output stream.
 * 
 * Note that the default value of the function input parameter is the standard command line output stream (std::cout).
 * 
 * The default parameter is defined in the POINT class header file (i.e. point.h) and not in the POINT class source file (i.e. point.cpp).
 */
void POINT::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.";
    output &lt;&lt; "\n&amp;X = " &lt;&lt; &amp;X &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.";
    output &lt;&lt; "\n&amp;Y = " &lt;&lt; &amp;Y &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.";    
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nX = " &lt;&lt; X &lt;&lt; ". // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\nY = " &lt;&lt; Y &lt;&lt; ". // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the POINT class header file (i.e. point.h).
 * 
 * The friend function is not a member of the POINT class, 
 * but the friend function has access to the private and protected members 
 * of the POINT class and not just to the public members of the POINT class.
 * 
 * The friend keyword only prefaces the function prototype of this function 
 * (and the prototype of this function is declared in the POINT class header file (i.e. point.h)). 
 * 
 * The friend keyword does not preface the definition of this function
 * (and the definition of this function is specified in the POINT class source file (i.e. point.cpp)).
 * 
 * // overloaded print function example one
 * POINT point_0;
 * std::cout &lt;&lt; point_0; // identical to point_0();
 * 
 * // overloaded print function example two
 * std::ofstream file;
 * POINT point_1;
 * file &lt;&lt; point_1; // identical to point_1(file);
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point)
{
    point.print(output);
    return output;
}

/**
 * The destructor method of the POINT class de-allocates memory which was used to 
 * instantiate the POINT object which is calling this function.
 * 
 * The destructor method of the POINT class is automatically called when 
 * the program scope in which the caller POINT object was instantiated terminates.
 */
POINT::~POINT()
{
    std::cout &lt;&lt; "\n\nDeleting the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>TRIANGLE_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the TRIANGLE class.</p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.h" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.h</a></p>
<hr />
<pre>/**
 * file: triangle.h
 * type: C++ (header file)
 * author: Karlina Ray Beringer
 * date: 20_NOVEMBER_2022
 * license: PUBLIC_DOMAIN
 */

// If TRIANGLE.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef TRIANGLE_H // If triangle.h has not already been linked to a source file (.cpp), 
#define TRIANGLE_H // then link this header file to the source file(s) which include this header file.

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.
#include "point.h" 

/**
 * Define a class which is used to instantiate TRIANGLE type objects.
 * 
 * (An object is a variable whose data type is user defined rather than native to the C++ programming language).
 * 
 * A TRIANGLE object represents an instance in which three unique POINT instances exist 
 * (and such that each one of those three POINT instances represents a unique coordinate pair within the tuple of three objects 
 *  which each represent exactle one two-dimensional point, POINT(X,Y), on a Cartesian grid).
 * 
 * A POINT object represents a whole number coordinate pair in the form (X,Y).
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of the same two-dimensional Cartesian grid.
 * 
 * X stores one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * Y stores one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 */
class TRIANGLE
{
private:
    POINT A, B, C; // data attributes
    bool points_represent_unique_coordinate_pairs(POINT point_0, POINT point_1, POINT point_2); // helper method
    bool points_form_nondegenerate_triangle(POINT point_0, POINT point_1, POINT point_2); // helper method
public:
    TRIANGLE(); // default constructor
    TRIANGLE(POINT A, POINT B, POINT C); // normal constructor
    TRIANGLE(int A_X, int A_Y, int B_X, int B_Y, int C_X, int C_Y); // normal constructor
    TRIANGLE(const TRIANGLE &amp; triangle); // copy constructor
    POINT get_A(); // getter method
    POINT get_B(); // getter method
    POINT get_C(); // getter method
    double get_side_length_AB(); // getter method
    double get_side_length_BC(); // getter method
    double get_side_length_CA(); // getter method
    double get_interior_angle_ABC(); // getter method
    double get_interior_angle_BCA(); // getter method
    double get_interior_angle_CAB(); // getter method
    double get_perimeter(); // getter method
    double get_area(); // getter method
    void print(std::ostream &amp; output = std::cout); // descriptor method
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRIANGLE &amp; triangle); // descriptor method
    ~TRIANGLE(); // destructor
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>TRIANGLE_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the TRIANGLE class.</p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle.cpp</a></p>
<hr />
<pre>/**
 * file: triangle.cpp
 * type: C++ (source file)
 * author: Karlina Ray Beringer
 * date: 24_NOVEMBER_2022
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRIANGLE class.
#include "triangle.h" 

/**
 * Determine whether or not point_0, point_1, and point_2 each represent unique coordinate pairs.
 * 
 * (Assume that point_0, point_1, and point_2 each represent valid POINT instances).
 * 
 * If each of the three POINT objects represent unique coordinate pairs, return true.
 * 
 * Otherwise, return false.
 */
bool TRIANGLE::points_represent_unique_coordinate_pairs(POINT point_0, POINT point_1, POINT point_2)
{
    if ((point_0.get_X() == point_1.get_X()) &amp;&amp; (point_0.get_Y() == point_1.get_Y())) 
    {
        std::cout &lt;&lt; "\n\npoint_0 and point_1 appear to represent the same coordinate pair.";
        std::cout &lt;&lt; "\npoint_0 := POINT(" &lt;&lt; point_0.get_X() &lt;&lt; ", " &lt;&lt; point_0.get_Y() &lt;&lt; ").";
        std::cout &lt;&lt; "\npoint_1 := POINT(" &lt;&lt; point_1.get_X() &lt;&lt; ", " &lt;&lt; point_1.get_Y() &lt;&lt; ").";
        return false;
    }
    if ((point_0.get_X() == point_2.get_X()) &amp;&amp; (point_0.get_Y() == point_2.get_Y())) 
    {
        std::cout &lt;&lt; "\n\npoint_0 and point_2 appear to represent the same coordinate pair.";
        std::cout &lt;&lt; "\npoint_0 := POINT(" &lt;&lt; point_0.get_X() &lt;&lt; ", " &lt;&lt; point_0.get_Y() &lt;&lt; ").";
        std::cout &lt;&lt; "\npoint_2 := POINT(" &lt;&lt; point_2.get_X() &lt;&lt; ", " &lt;&lt; point_2.get_Y() &lt;&lt; ").";
        return false;
    }
    if ((point_1.get_X() == point_2.get_X()) &amp;&amp; (point_1.get_Y() == point_2.get_Y())) 
    {
        std::cout &lt;&lt; "\n\npoint_1 and point_2 appear to represent the same coordinate pair.";
        std::cout &lt;&lt; "\npoint_1 := POINT(" &lt;&lt; point_1.get_X() &lt;&lt; ", " &lt;&lt; point_1.get_Y() &lt;&lt; ").";
        std::cout &lt;&lt; "\npoint_2 := POINT(" &lt;&lt; point_2.get_X() &lt;&lt; ", " &lt;&lt; point_2.get_Y() &lt;&lt; ").";
        return false;
    }
    if ((point_2.get_X() == point_0.get_X()) &amp;&amp; (point_2.get_Y() == point_0.get_Y())) 
    {
        std::cout &lt;&lt; "\n\npoint_2 and point_0 appear to represent the same coordinate pair.";
        std::cout &lt;&lt; "\npoint_2 := POINT(" &lt;&lt; point_2.get_X() &lt;&lt; ", " &lt;&lt; point_2.get_Y() &lt;&lt; ").";
        std::cout &lt;&lt; "\npoint_0 := POINT(" &lt;&lt; point_0.get_X() &lt;&lt; ", " &lt;&lt; point_0.get_Y() &lt;&lt; ").";
        return false;
    }
    return true;
}

/**
 * Determine whether or not point_0, point_1, and point_2 form a non-degenerate triangle.
 * 
 * (Assume that point_0, point_1, and point_2 each represent valid POINT instances).
 * 
 * A non-degenerate triangle is a triangle whose area is some positive real number quantity.
 * 
 * A degenerate triangle is a triangle whose area is zero (due to the fact that one line intersects each of the three points).
 * 
 * If point_0, point_1, and point_2 form a non-degenerate triangle, return true.
 * 
 * Otherwise, return false.
 */
bool TRIANGLE::points_form_nondegenerate_triangle(POINT point_0, POINT point_1, POINT point_2)
{
    if (!points_represent_unique_coordinate_pairs(point_0, point_1, point_2))
    {
        std::cout &lt;&lt; "\n\npoint_0, point_1, and point_2 do not each represent unique coordinate pairs.";
        std::cout &lt;&lt; "\nHence, points_form_degenerate_triangle(point_0, point_1, point_2) is returning false.";
        return false;
    }
    A = point_0;
    B = point_1;
    C = point_2;
    if (get_area() &lt;= 0) 
    {
        std::cout &lt;&lt; "\n\nWhen setting the POINT values of the caller TRIANGLE object using the given inputs, get_area() returned a non-positive number result.";
        std::cout &lt;&lt; "\nHence, points_form_nondegenerate_triangle(POINT point_0, POINT point_1, POINT point_2) is returning false.";
        return false;
    }
    return true;
}

/**
 * The default constructor method of the TRIANGLE class returns a TRIANGLE object 
 * whose POINT property named A represents the coordinate pair (0, 0),
 * whose POINT property named B represents the coordinate pair (0, 1), and
 * whose POINT property named C represents the coordinate pair (1, 0).
 */
TRIANGLE::TRIANGLE()
{
    std::cout &lt;&lt; "\n\nCreating the TRIANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0, 0);
    B = POINT(0, 1);
    C = POINT(1, 0);
}

/**
 * The normal constructor method of the TRIANGLE class (which takes six int type values as function inputs) returns a TRIANGLE object 
 * whose POINT property named A represents the coordinate pair (A_X, A_Y),
 * whose POINT property named B represents the coordinate pair (B_X, B_Y), and
 * whose POINT property named C represents the coordinate pair (C_X, C_Y)
 * if POINT(A_X, A_Y), POINT(B_X, B_Y), and POINT(C_X, C_Y) represent a non-degenerate triangle.
 * 
 * If POINT(A_X, A_Y, POINT(B_X, B_Y), and POINT(C_X, C_Y) do not represent a non-degenerate triangle,
 * this function will return a TRIANGLE object
 * whose POINT property named A represents the coordinate pair (0, 0),
 * whose POINT property named B represents the coordinate pair (0, 1), and
 * whose POINT property named C represents the coordinate pair (1, 0).
 */
TRIANGLE::TRIANGLE(int A_X, int A_Y, int B_X, int B_Y, int C_X, int C_Y)
{
    std::cout &lt;&lt; "\n\nCreating the TRIANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    POINT input_A = POINT(A_X, A_Y);
    POINT input_B = POINT(B_X, B_Y);
    POINT input_C = POINT(C_X, C_Y);
    if (points_form_nondegenerate_triangle(input_A, input_B, input_C))
    {
        A = input_A;
        B = input_B;
        C = input_C;
    }
    else
    {
        A = POINT(0, 0);
        B = POINT(0, 1);
        C = POINT(1, 0);
    }
}

/**
 * The normal constructor method of the TRIANGLE class (which takes three POINT objects as function inputs) returns a TRIANGLE object 
 * whose POINT property named A represents the same coordinate pair as the parameter named A,
 * whose POINT property named B represents the same coordinate pair as the parameter named B, and
 * whose POINT property named C represents the same coordinate pair as the parameter named C
 * if parameter A, parameter B, and parameter C represent a non-degenerate triangle.
 * 
 * If parameter A, parameter B, and parameter C do not represent a non-degenerate triangle,
 * this function will return a TRIANGLE object
 * whose POINT property named A represents the coordinate pair (0, 0),
 * whose POINT property named B represents the coordinate pair (0, 1), and
 * whose POINT property named C represents the coordinate pair (1, 0).
 * 
 * (The keyword this refers to the TRIANGLE object which is returned by the TRIANGLE(POINT A, POINT B, POINT C) method of the TRIANGLE class).
 */
TRIANGLE::TRIANGLE(POINT A, POINT B, POINT C)
{
    std::cout &lt;&lt; "\n\nCreating the TRIANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; ".";
    if (points_form_nondegenerate_triangle(A, B, C))
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
    }
    else
    {
        this -&gt; A = POINT(0, 0);
        this -&gt; B = POINT(0, 1);
        this -&gt; C = POINT(1, 0);
    }
}

/**
 * The copy constructor method of the TRIANGLE class returns a TRIANGLE object 
 * whose POINT property named A represents the same coordinate pair as the POINT property named A which belongs to the input TRIANGLE object,
 * whose POINT property named B represents the same coordinate pair as the POINT property named B which belongs to the input TRIANGLE object, and
 * whose POINT property named C represents the same coordinate pair as the POINT property named C which belongs to the input TRIANGLE object. 
 * 
 * (The keyword this refers to the TRIANGLE object which is returned by the copy constructor method of the TRIANGLE class).
 */
TRIANGLE::TRIANGLE(const TRIANGLE &amp; triangle)
{
    std::cout &lt;&lt; "\n\nCreating the TRIANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; ".";
    this -&gt; A = triangle.A;
    this -&gt; B = triangle.B;
    this -&gt; C = triangle.C;
}

/** 
 * The getter method of the TRIANGLE class named get_A() returns the POINT type value of the caller TRIANGLE object's A property.
 */
POINT TRIANGLE::get_A()
{
    return A;
}

/** 
 * The getter method of the TRIANGLE class named get_B() returns the POINT type value of the caller TRIANGLE object's B property.
 */
POINT TRIANGLE::get_B()
{
    return B;
}

/** 
 * The getter method of the TRIANGLE class named get_C() returns the POINT type value of the caller TRIANGLE object's C property.
 */
POINT TRIANGLE::get_C()
{
    return C;
}

/** 
 * The getter method of the TRIANGLE class named get_side_length_AB() returns the approximate length of the shortest path between points A and B.
 */
double TRIANGLE::get_side_length_AB()
{
    return A.get_distance_from(B);
}

/** 
 * The getter method of the TRIANGLE class named get_side_length_BC() returns the approximate length of the shortest path between points B and C.
 */
double TRIANGLE::get_side_length_BC()
{
    return B.get_distance_from(C);
}

/** 
 * The getter method of the TRIANGLE class named get_side_length_CA() returns the approximate length of the shortest path between points C and A.
 */
double TRIANGLE::get_side_length_CA()
{
    return C.get_distance_from(A);
}

/**
 * The getter method of the TRIANGLE class named get_interior_angle_ABC() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points A, B, anc C in the order specified by this sentence.
 * 
 * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */
double TRIANGLE::get_interior_angle_ABC()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = get_side_length_BC(); // a represents the length of the line segment whose endpoints are B and C.
    b = get_side_length_CA(); // b represents the length of the line segment whose endpoints are C and A.
    c = get_side_length_AB(); // c represents the length of the line segment whose endpoints are A and B.
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_b;
}

/**
 * The getter method of the TRIANGLE class named get_interior_angle_BCA() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points B, C, and A in the order specified by this sentence.
 * 
 * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */
double TRIANGLE::get_interior_angle_BCA()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = get_side_length_BC(); // a represents the length of the line segment whose endpoints are B and C.
    b = get_side_length_CA(); // b represents the length of the line segment whose endpoints are C and A.
    c = get_side_length_AB(); // c represents the length of the line segment whose endpoints are A and B.
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_c;
}

/**
 * The getter method of the TRIANGLE class named get_interior_angle_CAB() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points C, A, and B in the order specified by this sentence.
 * 
 * The function below uses Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */   
double TRIANGLE::get_interior_angle_CAB()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = get_side_length_BC(); // a represents the length of the line segment whose endpoints are B and C (and which are points of the caller TRIANGLE object of this function represents).
    b = get_side_length_CA(); // b represents the length of the line segment whose endpoints are C and A (and which are points of the caller TRIANGLE object of this function represents).
    c = get_side_length_AB(); // c represents the length of the line segment whose endpoints are A and B (and which are points of the caller TRIANGLE object of this function represents).
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_a;
}

/** 
 * The getter method of the TRIANGLE class named get_perimeter() returns the approximate sum of the three side lengths 
 * of the triangle which the caller TRIANGLE object represents.
 */
double TRIANGLE::get_perimeter()
{
    return get_side_length_AB() + get_side_length_BC() + get_side_length_CA();
}

/** 
 * The getter method of the TRIANGLE class named get_area() returns the approximate area of the two-dimensional space whose bounds are 
 * the shortest paths between points A, B, and C of the triangle which the caller TRIANGLE object represents.
 * 
 * This function uses Heron's Formula to compute the area of a triangle using that triangle's side lengths as formula inputs.
 */
double TRIANGLE::get_area()
{
    double s = 0.0, a = 0.0, b = 0.0, c = 0.0;
    s = get_perimeter() / 2; // s is technically referred to as the semiperimter of the triangle which the caller TRIANGLE object of this function represents.
    a = get_side_length_BC(); // a represents the length of the line segment whose endpoints are B and C (and which are points of the caller TRIANGLE object of this function represents).
    b = get_side_length_CA(); // b represents the length of the line segment whose endpoints are C and A (and which are points of the caller TRIANGLE object of this function represents).
    c = get_side_length_AB(); // c represents the length of the line segment whose endpoints are A and B (and which are points of the caller TRIANGLE object of this function represents).
    return sqrt(s * (s - a) * (s - b) * (s - c)); // Use Heron's Formula to compute the area of the triangle whose points are A, B, and C (and which are points of the caller TRIANGLE object of this function represents).
}

/**
 * The print method of the TRIANGLE class prints a description of the caller TRIANGLE object to the output stream.
 * 
 * Note that the default value of the function input parameter is the standard command line output stream (std::cout).
 * 
 * The default parameter is defined in the TRIANGLE class header file (i.e. triangle.h) and not in the TRIANGLE class source file (i.e. triangle.cpp).
 */
void TRIANGLE::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRIANGLE) = " &lt;&lt; sizeof(TRIANGLE) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = get_side_length_BC() = " &lt;&lt; get_side_length_BC() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = get_side_length_CA() = " &lt;&lt; get_side_length_CA() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.";
    output &lt;&lt; "\nc = get_side_length_AB() = " &lt;&lt; get_side_length_AB() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nA.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\nB.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nC.get_slope_of_line_to(A) = " &lt;&lt; C.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.";
    output &lt;&lt; "\nget_interior_angle_CAB() =  " &lt;&lt; get_interior_angle_CAB() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\nget_interior_angle_ABC() =  " &lt;&lt; get_interior_angle_ABC() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\nget_interior_angle_BCA() =  " &lt;&lt; get_interior_angle_BCA() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\nget_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = " &lt;&lt; get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() &lt;&lt; ". // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the TRIANGLE class header file (i.e. triangle.h).
 * 
 * The friend function is not a member of the TRIANGLE class, 
 * but the friend function has access to the private and protected members 
 * of the TRIANGLE class and not just to the public members of the TRIANGLE class.
 * 
 * The friend keyword only prefaces the function prototype of this function 
 * (and the prototype of this function is declared in the TRIANGLE class header file (i.e. triangle.h)). 
 * 
 * The friend keyword does not preface the definition of this function
 * (and the definition of this function is specified in the TRIANGLE class source file (i.e. triangle.cpp)).
 * 
 * // overloaded print function example one
 * TRIANGLE triangle_0;
 * std::cout &lt;&lt; triangle_0; // identical to triangle_0();
 * 
 * // overloaded print function example two
 * std::ofstream file;
 * TRIANGLE triangle_1;
 * file &lt;&lt; triangle_1; // identical to triangle_1(file);
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRIANGLE &amp; triangle)
{
    triangle.print(output);
    return output;
}

/**
 * The destructor method of the TRIANGLE class de-allocates memory which was used to 
 * instantiate the TRIANGLE object which is calling this function.
 * 
 * The destructor method of the TRIANGLE class is automatically called when 
 * the program scope in which the caller TRIANGLE object was instantiated terminates.
 */
TRIANGLE::~TRIANGLE()
{
    std::cout &lt;&lt; "\n\nDeleting the TRIANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>PROGRAM_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the client which implements the TRIANGLE class. The client executes a series of unit tests which demonstrate how the TRIANGLE class methods work.</p>
<p>C++_source_file: <a style="background:#000000;color:#00ff00;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester.cpp" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester.cpp</a></p>
<hr />
<pre>/**
 * file: triangle_class_tester.cpp
 * type: C++ (source file)
 * date: 21_NOVEMBER_2022
 * author: Karlina Ray Beringer
 * license: PUBLIC_DOMAIN 
 */

#include "triangle.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRIANGLE class.

/* function prototypes */
void unit_test_0(std::ostream &amp; output);
void unit_test_1(std::ostream &amp; output);
void unit_test_2(std::ostream &amp; output);
void unit_test_3(std::ostream &amp; output);
void unit_test_4(std::ostream &amp; output);

// Unit Test # 0: TRIANGLE class default constructor, TRIANGLE class print method, and TRIANGLE class destructor.
void unit_test_0(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 0: TRIANGLE class default constructor, TRIANGLE class print method, and TRIANGLE class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRIANGLE point;";
    output &lt;&lt; "\ntriangle.print(output);";
    TRIANGLE triangle;
    triangle.print(output);
}

// Unit Test # 1: TRIANGLE class default constructor, TRIANGLE class overloaded ostream operator method, TRIANGLE getter methods, and TRIANGLE class destructor.
void unit_test_1(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 1: TRIANGLE class default constructor, TRIANGLE class overloaded ostream operator method, TRIANGLE getter methods, and TRIANGLE class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRIANGLE triangle;";
    output &lt;&lt; "\nPOINT copy_of_point_A = triangle.get_A();";
    output &lt;&lt; "\nPOINT copy_of_point_B = triangle.get_B();";
    output &lt;&lt; "\nPOINT copy_of_point_C = triangle.get_C();";
    output &lt;&lt; "\noutput &lt;&lt; triangle;";
    TRIANGLE triangle;
    POINT copy_of_point_A = triangle.get_A();
    POINT copy_of_point_B = triangle.get_B();
    POINT copy_of_point_C = triangle.get_C();
    output &lt;&lt; triangle;
    output &lt;&lt; "\n\ncopy_of_point_A.print(output);";
    copy_of_point_A.print(output);
    output &lt;&lt; "\n\noutput &lt;&lt; copy_of_point_A;";
    output &lt;&lt; copy_of_point_A;
    output &lt;&lt; "\n\ncopy_of_point_B.print(output);";
    copy_of_point_B.print(output);
    output &lt;&lt; "\n\noutput &lt;&lt; copy_of_point_B;";
    output &lt;&lt; copy_of_point_B;
    output &lt;&lt; "\n\ncopy_of_point_C.print(output);";
    copy_of_point_C.print(output);
    output &lt;&lt; "\n\noutput &lt;&lt; copy_of_point_C;";
    output &lt;&lt; copy_of_point_C;
    output &lt;&lt; "\n\ntriangle.get_side_length_AB() = " &lt;&lt; triangle.get_side_length_AB() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_side_length_BC() = " &lt;&lt; triangle.get_side_length_BC() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_side_length_CA() = " &lt;&lt; triangle.get_side_length_CA() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_interior_angle_ABC() = " &lt;&lt; triangle.get_interior_angle_ABC() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_interior_angle_BCA() := " &lt;&lt; triangle.get_interior_angle_BCA() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_interior_angle_CAB() = " &lt;&lt; triangle.get_interior_angle_CAB() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_perimeter() = " &lt;&lt; triangle.get_perimeter() &lt;&lt; ".";
    output &lt;&lt; "\ntriangle.get_area() = " &lt;&lt; triangle.get_area() &lt;&lt; ".";
}


// Unit Test # 2: TRIANGLE class normal constructors, TRIANGLE class copy constructor, TRIANGLE class print method, and TRIANGLE class destructor.
void unit_test_2(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 2: TRIANGLE class normal constructors, TRIANGLE class copy constructor, TRIANGLE class print method, and TRIANGLE class destructor.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRIANGLE triangle_0 = TRIANGLE(-1, -1, 0, 5, 2, -5); // normal constructor which takes exactly 6 int type values as function inputs";
    output &lt;&lt; "\nTRIANGLE triangle_1 = TRIANGLE( POINT(-3,-3), POINT(-4,-8), POINT(0,1) ); // normal constructor which takes 3 POINT type values as function inputs";
    output &lt;&lt; "\nTRIANGLE triangle_2 = TRIANGLE(triangle_0); // copy constructor which takes 1 TRIANGLE type value as function input";
    output &lt;&lt; "\ntriangle_0.print(output);";
    output &lt;&lt; "\ntriangle_1.print(output);";
    output &lt;&lt; "\ntriangle_2.print(output);";
    TRIANGLE triangle_0 = TRIANGLE(-1, -1, 0, 5, 2, -5); // normal constructor which takes exactly 6 int type values as function inputs
    TRIANGLE triangle_1 = TRIANGLE( POINT(-3,-3), POINT(-4,-8), POINT(0,1) ); // normal constructor which takes 3 POINT type values as function inputs
    TRIANGLE triangle_2 = TRIANGLE(triangle_0); // copy constructor which takes 1 TRIANGLE type value as function input
    triangle_0.print(output);
    triangle_1.print(output);
    triangle_2.print(output);
}

// Unit Test # 3: degenerate triangle examples.
void unit_test_3(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 3: degenerate triangle examples.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRIANGLE triangle_0 = TRIANGLE( POINT(-1,-1), POINT(0,0), POINT(1,1) ); // Because these inputs would generate a degenerate triangle, default coordinate values are used for A, B, and C instead of the input values.";
    output &lt;&lt; "\nTRIANGLE triangle_1 = TRIANGLE( POINT(-1,-1), POINT(0,0), POINT(-1,-1) ); // Because these inputs represent only 2 unique points instead of 3 unique points, default coordinate values are used for A, B, and C instead of the input values.";
    output &lt;&lt; "\ntriangle_0.print(output);";
    output &lt;&lt; "\ntriangle_1.print(output);";
    TRIANGLE triangle_0 = TRIANGLE( POINT(-1,-1), POINT(0,0), POINT(1,1) ); // Because these inputs would generate a degenerate triangle, default coordinate values are used for A, B, and C instead of the input values.
    TRIANGLE triangle_1 = TRIANGLE(-1, -1, 0, 0, -1, -1); // Because these inputs represent only 2 unique points instead of 3 unique points, default coordinate values are used for A, B, and C instead of the input values.
    triangle_0.print(output);
    triangle_1.print(output);
}

// Unit Test # 4: Demonstrate how the methods of the POINT class cannot be called by a TRIANGLE object due to the fact that the methods of the POINT class each have uniquely corresponding function prototypes which are prefaced with the private access specifier in the POINT class header file (i.e. POINT.h).
void unit_test_4(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// Unit Test # 4: Demonstrate how the methods of the POINT class cannot be called by a TRIANGLE object due to the fact that the methods of the POINT class each have uniquely corresponding function prototypes which are prefaced with the private access specifier in the POINT class header file (i.e. POINT.h).";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRIANGLE triangle;";
    output &lt;&lt; "\ntriangle.print(output);";
    TRIANGLE triangle;
    triangle.print(output);
    output &lt;&lt; "\nPOINT copy_A = triangle.get_A();";
    output &lt;&lt; "\ncopy_A.print(output);";
    POINT copy_A = triangle.get_A();
    copy_A.print(output);
    copy_A.set_X(33); // The setter method of the POINT class is public. Therefore, that method can be invoked from the program scope in which the POINT type variable copy_A is instantiated.
    output &lt;&lt; "\ncopy_A.set_X(33); // The setter method of the POINT class is public. Therefore, that method can be invoked from the program scope in which the POINT type variable copy_A is instantiated.";
    output &lt;&lt; "\ncopy_A.print(output); // The print method of the POINT class is public. Therefore, that method can be invoked from the program scope in which the POINT type variable copy_A is insstantiated.";
    /*
    output &lt;&lt; "\ntriangle.A.get_X() = " &lt;&lt; triangle.A.get_X() &lt;&lt; ". // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\ntriangle.A.get_Y() = " &lt;&lt; triangle.A.get_Y() &lt;&lt; ". // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\ntriangle.A.set_X(25) = " &lt;&lt; triangle.A.set_X(25) &lt;&lt; ". // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\ntriangle.A.get_Y(666) = " &lt;&lt; triangle.A.set_Y(666) &lt;&lt; ". // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    triangle.print(output);
    */
    output &lt;&lt; "\n// COMMENTED OUT: triangle.A.get_X(); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\n// COMMENTED OUT: triangle.A.get_Y(); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\n// COMMENTED OUT: triangle.A.set_X(25); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
    output &lt;&lt; "\n// COMMENTED OUT: triangle.A.get_Y(666); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.";
}

/* program entry point */
int main()
{
    // Declare a file output stream object.
    std::ofstream file;

    // Set the number of digits of floating-point numbers which are printed to the command line terminal to 100 digits.
    std::cout.precision(100);

    // Set the number of digits of floating-point numbers which are printed to the file output stream to 100 digits.
    file.precision(100);

    /**
     * If triangle_class_tester_output.txt does not already exist in the same directory as triangle_class_tester.cpp, 
     * create a new file named triangle_class_tester_output.txt.
     * 
     * Open the plain-text file named triangle_class_tester_output.txt 
     * and set that file to be overwritten with program data.
     */
    file.open("triangle_class_tester_output.txt");

    // Print an opening message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nStart Of Program";
    std::cout &lt;&lt; "\n--------------------------------";

    // Print an opening message to the file output stream.
    file &lt;&lt; "--------------------------------";
    file &lt;&lt; "\nStart Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Implement a series of unit tests which demonstrate the functionality of TRIANGLE class variables.
    unit_test_0(std::cout);
    unit_test_0(file);
    unit_test_1(std::cout);
    unit_test_1(file);
    unit_test_2(std::cout);
    unit_test_2(file);
    unit_test_3(std::cout);
    unit_test_3(file);
    unit_test_4(std::cout);
    unit_test_4(file);

    // Print a closing message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nEnd Of Program";
    std::cout &lt;&lt; "\n--------------------------------\n\n";

    // Print a closing message to the file output stream.
    file &lt;&lt; "\n\n--------------------------------";
    file &lt;&lt; "\nEnd Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Close the file output stream.
    file.close();

    // Exit the program.
    return 0;
}
</pre>
<hr />
<p><strong>SAMPLE_PROGRAM_OUTPUT</strong></p>
<hr />
<p>The text in the preformatted text box below was generated by one use case of the C++ program featured in this <a style="background:#ff9000;color:#000000;" href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a> tutorial web page.</p>
<p>plain-text_file: <a style="background:#000000;color:#ff9000;" href="https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester_output.txt" target="_blank" rel="noopener">https://github.com/karlinarayberinger/karlina_object_2022_starter_pack/blob/main/triangle_class_tester_output.txt</a></p>
<hr />
<pre>--------------------------------
Start Of Program
--------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 0: TRIANGLE class default constructor, TRIANGLE class print method, and TRIANGLE class destructor.
--------------------------------------------------------------------------------------------------
TRIANGLE point;
triangle.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ed0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9ed0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9ed8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ee0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(0,0). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 1: TRIANGLE class default constructor, TRIANGLE class overloaded ostream operator method, TRIANGLE getter methods, and TRIANGLE class destructor.
--------------------------------------------------------------------------------------------------
TRIANGLE triangle;
POINT copy_of_point_A = triangle.get_A();
POINT copy_of_point_B = triangle.get_B();
POINT copy_of_point_C = triangle.get_C();
output &lt;&lt; triangle;

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ed0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9ed0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9ed8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ee0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(0,0). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

copy_of_point_A.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9eb8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9eb8. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ebc. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 0. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 0. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

output &lt;&lt; copy_of_point_A;

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9eb8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9eb8. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ebc. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 0. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 0. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

copy_of_point_B.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ec0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9ec0. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ec4. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 0. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 1. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

output &lt;&lt; copy_of_point_B;

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ec0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9ec0. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ec4. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 0. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 1. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

copy_of_point_C.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ec8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9ec8. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ecc. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 1. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 0. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

output &lt;&lt; copy_of_point_C;

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ec8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9ec8. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ecc. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 1. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 0. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------

triangle.get_side_length_AB() = 1.
triangle.get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125.
triangle.get_side_length_CA() = 1.
triangle.get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625.
triangle.get_interior_angle_BCA() := 45.0000380099060208749506273306906223297119140625.
triangle.get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125.
triangle.get_perimeter() = 3.41421356237309492343001693370752036571502685546875.
triangle.get_area() = 0.4999999999999997779553950749686919152736663818359375.

--------------------------------------------------------------------------------------------------
Unit Test # 2: TRIANGLE class normal constructors, TRIANGLE class copy constructor, TRIANGLE class print method, and TRIANGLE class destructor.
--------------------------------------------------------------------------------------------------
TRIANGLE triangle_0 = TRIANGLE(-1, -1, 0, 5, 2, -5); // normal constructor which takes exactly 6 int type values as function inputs
TRIANGLE triangle_1 = TRIANGLE( POINT(-3,-3), POINT(-4,-8), POINT(0,1) ); // normal constructor which takes 3 POINT type values as function inputs
TRIANGLE triangle_2 = TRIANGLE(triangle_0); // copy constructor which takes 1 TRIANGLE type value as function input
triangle_0.print(output);
triangle_1.print(output);
triangle_2.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9e90. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9e90. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9e98. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ea0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(-1,-1). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(2,-5). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 10.198039027185568983213670435361564159393310546875. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 6.08276253029821933893117602565325796604156494140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 6. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = -1.3333333333333332593184650249895639717578887939453125. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  133.66789305056954617612063884735107421875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  20.772272227633603591812061495147645473480224609375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  25.559986761421026102425457793287932872772216796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.000152039624168764930800534784793853759765625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 21.280801557483787433966426760889589786529541015625. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 10.9999999999999946709294817992486059665679931640625. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9eb0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9eb0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9eb8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ec0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(-3,-3). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-4,-8). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(0,1). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 9.848857801796103927927106269635260105133056640625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 5.0990195135927844916068352176807820796966552734375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 2.25. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 1.3333333333333332593184650249895639717578887939453125. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  154.440165278203068055518087930977344512939453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  12.6525671877242711360622706706635653972625732421875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  12.907419573696753190006347722373902797698974609375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.00015203962408349980250932276248931884765625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 19.94787731538888664317710208706557750701904296875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 5.49999999999998312461002569762058556079864501953125. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ed0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9ed0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9ed8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ee0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(-1,-1). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(2,-5). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 10.198039027185568983213670435361564159393310546875. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 6.08276253029821933893117602565325796604156494140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 6. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = -1.3333333333333332593184650249895639717578887939453125. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  133.66789305056954617612063884735107421875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  20.772272227633603591812061495147645473480224609375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  25.559986761421026102425457793287932872772216796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.000152039624168764930800534784793853759765625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 21.280801557483787433966426760889589786529541015625. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 10.9999999999999946709294817992486059665679931640625. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 3: degenerate triangle examples.
--------------------------------------------------------------------------------------------------
TRIANGLE triangle_0 = TRIANGLE( POINT(-1,-1), POINT(0,0), POINT(1,1) ); // Because these inputs would generate a degenerate triangle, default coordinate values are used for A, B, and C instead of the input values.
TRIANGLE triangle_1 = TRIANGLE( POINT(-1,-1), POINT(0,0), POINT(-1,-1) ); // Because these inputs represent only 2 unique points instead of 3 unique points, default coordinate values are used for A, B, and C instead of the input values.
triangle_0.print(output);
triangle_1.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9eb0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9eb0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9eb8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ec0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(0,0). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ed0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9ed0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9ed8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ee0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(0,0). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
// Unit Test # 4: Demonstrate how the methods of the POINT class cannot be called by a TRIANGLE object due to the fact that the methods of the POINT class each have uniquely corresponding function prototypes which are prefaced with the private access specifier in the POINT class header file (i.e. POINT.h).
--------------------------------------------------------------------------------------------------
TRIANGLE triangle;
triangle.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ed0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRIANGLE sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;A = 0x7ffce51e9ed0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffce51e9ed8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffce51e9ee0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRIANGLE) = 24. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRIANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
A = POINT(0,0). // A represents a point (which is neither B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = get_side_length_BC() = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = get_side_length_CA() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = get_side_length_AB() = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
get_interior_angle_CAB() =  90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
get_interior_angle_ABC() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
get_interior_angle_BCA() =  45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the triangle represented by the caller TRIANGLE object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the triangle which the caller TRIANGLE object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A, B, and C.
--------------------------------------------------------------------------------------------------
POINT copy_A = triangle.get_A();
copy_A.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffce51e9ec8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.
&amp;X = 0x7ffce51e9ec8. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.
&amp;Y = 0x7ffce51e9ecc. // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
X = 0. // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.
Y = 0. // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.
--------------------------------------------------------------------------------------------------
copy_A.set_X(33); // The setter method of the POINT class is public. Therefore, that method can be invoked from the program scope in which the POINT type variable copy_A is instantiated.
copy_A.print(output); // The print method of the POINT class is public. Therefore, that method can be invoked from the program scope in which the POINT type variable copy_A is insstantiated.
// COMMENTED OUT: triangle.A.get_X(); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.
// COMMENTED OUT: triangle.A.get_Y(); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.
// COMMENTED OUT: triangle.A.set_X(25); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.
// COMMENTED OUT: triangle.A.get_Y(666); // Note that this command can only be executed if the POINT type data member named A of a TRIANGLE instance is public.

--------------------------------
End Of Program
--------------------------------
</pre>
<hr />
<p>This web page was last updated on 24_NOVEMBER_2022. The content displayed on this web page is licensed as <a style="background:#000000;color:#ff9000;" href="https://karlinaobject.wordpress.com/public_domain/" target="_blank" rel="noopener">PUBLIC_DOMAIN</a> intellectual property.</p>
<hr />	
