<hr>
<p><strong>HASH_TABLE</strong></p>
<hr>
<p><span style="background: #ffff00">The <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> program featured in this tutorial web page demonstrates the concept of Object Oriented Programming (<a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">OOP</a>). The program implements a user defined data type for instantiating <strong>HASH_TABLE</strong> type objects. Each HASH_TABLE type object represents an array whose elements are <a style="background: #000000;color: #00ff00" href="https://karlinaobject.wordpress.com/linked_list/" target="_blank" rel="noopener">LINKED_LIST</a> type objects (and each LINKED_LIST object represents a singly-linked list whose elements are <strong>NODE</strong> type <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)" target="_blank" rel="noopener">struct</a> variables). A NODE can be inserted into the HASH_TABLE using a <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">hash function</a> which takes that NODE&#8217;s key value as the function input and returns an index of the HASH_TABLE array in which to store that NODE as the last element of the LINKED_LIST which is located at that particular array index.</span></p>
<p><span style="background: #00ff00">To view hidden text inside of the preformatted text boxes below, scroll horizontally.</span></p>
<hr>
<p><strong>SOFTWARE_APPLICATION_COMPONENTS</strong></p>
<hr>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.cpp</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver.cpp</a></p>
<p>plain-text_file: <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver_output.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver_output.txt</a></p>
<hr>
<p><strong>PROGRAM_COMPILATION_AND_EXECUTION</strong></p>
<hr>
<p>STEP_0: Copy and paste the C++ code from the files named <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.h" target="_blank" rel="noopener">public_linked_list.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.cpp" target="_blank" rel="noopener">public_linked_list.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.h" target="_blank" rel="noopener">hash_table.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.cpp" target="_blank" rel="noopener">hash_table.cpp</a>, and <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver.cpp" target="_blank" rel="noopener">hash_table_driver.cpp</a> into their own new text editor documents and save those documents using their corresponding file names:</p>
<pre>public_linked_list.h</pre>
<pre>public_linked_list.cpp</pre>
<pre>hash_table.h</pre>
<pre>hash_table.cpp</pre>
<pre>hash_table_driver.cpp</pre>
<p>STEP_1: Open a <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a> command line terminal application and set the current directory to wherever the C++ is located on the local machine (e.g. Desktop).</p>
<pre>cd Desktop</pre>
<p>STEP_2: Compile the C++ file into machine-executable instructions (i.e. object file) and then into an executable piece of software named <strong>app</strong> using the following command:</p>
<pre>g++ hash_table_driver.cpp hash_table.cpp public_linked_list.cpp -o app</pre>
<p>STEP_3: If the program compilation command does not work, then use the following command to install the C++ compiler:</p>
<pre>sudo apt install build-essential</pre>
<p>STEP_4: Observe program results on the command line terminal and in the <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver_output.txt" target="_blank" rel="noopener">output file</a>.</p>
<hr>
<p><strong>LINKED_LIST_CLASS_HEADER</strong></p>
<hr>
<p>The following header file contains the preprocessing directives and function prototypes of the LINKED_LIST class.</p>
<p><span style="background: #00ff00">When copy-pasting the source code from the preformatted text box below into a text editor document, remove the spaces between the angle brackets and the library names in the preprocessing directives code block. (The spaces were inserted between the library names and angle brackets in the preformatted text box below in order to prevent the WordPress server from misinterpreting those C++ library references as <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a> tags in the source code of this web page).</span></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.h</a></p>
<hr>
<pre>/**
 * file: public_linked_list.h
 * type: C++ (header file)
 * author: karbytes
 * date: 08_DECEMBER_2022
 * license: PUBLIC_DOMAIN
 */

/* preprocessing directives */
#ifndef LINKED_LIST_H // If public_linked_list.h has not already been linked to a source file (.cpp), 
#define LINKED_LIST_H // then link this header file to the source file(s) which include this header file.

/* preprocessing directives */
#include &lt; iostream &gt; // library for defining objects which handle command line input and command line output
#include &lt; fstream &gt; // library for defining objects which handle file input and file output
#include &lt; string &gt; // library which defines a sequence of text characters (i.e. char type values) as a string type variable

/**
 * A variable whose data type is NODE is a tuple consisting of two variables
 * such that one of those variables stores some arbitrary piece of information (i.e. key)
 * while the other variable stores the address of a NODE variable (i.e. next).
 * 
 * Like a C++ class, a C++ struct is a user defined data type.
 * 
 * Note that each of the members of a struct variable is public and neither private nor protected.
 * 
 * Note that each of the members of a struct variable is a variable and not a function.
 */
struct NODE
{
    std::string key; // key stores an arbitrary sequence of characters
    NODE * next; // next stores the memory address of a NODE type variable.
};

/**
 * A variable whose data type is LINKED_LIST is a software object whose data attributes
 * consist of exactly one pointer-to-NODE type variable which is assumed to be the 
 * first node of a linear and unidirectional (i.e. singly-linked) linked list.
 * 
 * When a LINKED_LIST type variable is declared, a dynamic NODE type variable is created
 * and the memory address of that dynamic NODE type variable is stored in a pointer-to-NODE
 * type variable named head.
 * 
 * After a LINKED_LIST type variable is created and before that variable is deleted, 
 * NODE type elements can be inserted into the list which the LINKED_LIST type variable represents
 * and NODE type elements can be removed from the list which the LINKED_LIST type variable represents.
 * 
 * After a LINKED_LIST type variable is created and before that variable is deleted,
 * that variable (i.e. object) can invoke a print function which prints a description
 * of the caller LINKED_LIST object.
 * 
 * When a LINKED_LIST variable is deleted, the pointer-to-NODE type variable named head 
 * (which was assigned memory during program runtime rather than during program compilation time) 
 * is deleted.
 */
class LINKED_LIST
{
public:
    NODE * head; // head stores the memory address of the first NODE type element of a LINKED_LIST type data structure.
    bool remove_node_with_key(std::string key); // helper method
    LINKED_LIST(); // constructor
    void insert_node_at_end_of_list(NODE * node); // setter method
    void remove_nodes_with_key(std::string key); // setter method
    int get_number_of_nodes_in_list(); // getter method
    void print(std::ostream &amp; output = std::cout); // descriptor method
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, LINKED_LIST &amp; linked_list); // descriptor method
    ~LINKED_LIST(); // destructor
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr>
<p><strong>LINKED_LIST_CLASS_SOURCE_CODE</strong></p>
<hr>
<p>The following source code defines the functions of the LINKED_LIST class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/public_linked_list.cpp</a></p>
<hr>
<pre>/**
 * file: public_linked_list.cpp
 * type: C++ (source file)
 * author: karbytes
 * date: 08_DECEMBER_2022
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the LINKED_LIST class.
#include "public_linked_list.h" 

/**
 * Starting at the NODE type element whose memory address is stored in head and ending at NULL,
 * traverse the singly-linked list comprised of NODE type elements such that each of those elements are visited.
 * 
 * If the current element's key is identical to the input key,
 * set the next property of the previous node to 
 * the memory address of the node which is next in the list after the current element
 * and return true.
 * 
 * If at least one node in the list has a key which is identical to the input key,
 * the function will return true. Otherwise, the function will return false.
 * 
 * (The method of using two pointers, p and q, to traverse the list is colloquially described as "inchworming"
 * because those two pointers metaphorically resemble opposite ends of an inchworm as that insect stretches its
 * front end forward by approximately one inch before moving its back end to where its front end is located).
 */
bool LINKED_LIST::remove_node_with_key(std::string key)
{
    NODE * p = head;
    NODE * q = head;
    while (q)
    {
        if ((q -&gt; key == key) &amp;&amp; (q != head))
        {
            std::cout &lt;&lt; "\n\nThe NODE whose memory address is " &lt;&lt; q &lt;&lt; " is being removed from the LINKED_LIST...";
            p -&gt; next = q -&gt; next;
            return true;
        }
        p = q;
        q = p -&gt; next;
    }
    return false;
}

/**
 * Instantiate an "empty" linked list (i.e. a linked list with only a head node and no "body nodes").
 * 
 * Note that only "body nodes" may be inserted into or else removed from a linked list which a LINKED_LIST type object represents.
 */
LINKED_LIST::LINKED_LIST()
{
    std::cout &lt;&lt; "\n\nCreating the LINKED_LIST type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    head = new NODE;
    head -&gt; key = "HEAD";
    head -&gt; next = NULL;
}

/**
 * Make the input NODE type variable the last element of the linked list represented by the caller LINKED_LIST object.
 * 
 * (Note that using a NODE which is currently an element of the caller LINKED_LIST as the input to this function
 * will turn the linked list represented by the caller LINKED_LIST object into a closed loop rather than a finite linear sequence). 
 * 
 * (The method of using two pointers, p and q, to traverse the list is colloquially described as "inchworming"
 * because those two pointers metaphorically resemble opposite ends of an inchworm as that insect stretches its
 * front end forward by approximately one inch before moving its back end to where its front end is located).
 */
void LINKED_LIST::insert_node_at_end_of_list(NODE * node)
{
    NODE * p = head;
    NODE * q = head;
    while (q)
    {
        p = q;
        q = p -&gt; next;
    }
    std::cout &lt;&lt; "\n\nThe NODE whose memory address is " &lt;&lt; p &lt;&lt; " is being inserted into the LINKED_LIST as the last element of that list...";
    p -&gt; next = node; 
    node -&gt; next = NULL;
}

/**
 * Remove all nodes from the linked list represented by the caller LINKED_LIST object 
 * whose key values are identical to the input key value.
 */
void LINKED_LIST::remove_nodes_with_key(std::string key)
{
    bool at_least_one_node_was_removed = false;
    at_least_one_node_was_removed = remove_node_with_key(key);
    while (at_least_one_node_was_removed) at_least_one_node_was_removed = remove_node_with_key(key);
}

/**
 * Return the natural number count of NODE type elements inside the singly-linked list which
 * the caller LINKED_LIST object represents.
 * 
 * Starting with the head and ending with NULL,
 * traverse sequentially down the list of NODE type elements and
 * count each element in the exist. 
 * 
 * If the linked list is "empty" (i.e. the head is the only NODE in the caller LINKED_LIST),
 * one will be returned.
 * 
 * (The method of using two pointers, p and q, to traverse the list is colloquially described as "inchworming"
 * because those two pointers metaphorically resemble opposite ends of an inchworm as that insect stretches its
 * front end forward by approximately one inch before moving its back end to where its front end is located).
 */
int LINKED_LIST::get_number_of_nodes_in_list()
{
    int node_count = 0;
    NODE * p = head;
    NODE * q = head;
    while (q)
    {
        p = q;
        q = p -&gt; next;
        node_count += 1;
    }
    return node_count;
}

/**
 * The print method of the LINKED_LIST class prints a description of the caller LINKED_LIST object to the output stream.
 * 
 * A description of each NODE type element of the linked list which the caller LINKED_LIST object represents will be printed to the output stream
 * in the order those elements were inserted into the list by "inchworming" from NODE_0 to NODE_N (where N is the total number of nodes in the list).
 * 
 * (The method of using two pointers, p and q, to traverse the list is colloquially described as "inchworming"
 * because those two pointers metaphorically resemble opposite ends of an inchworm as that insect stretches its
 * front end forward by approximately one inch before moving its back end to where its front end is located).
 * 
 * Note that the default value of the function input parameter is the standard command line output stream (std::cout).
 * 
 * The default parameter is defined in the LINKED_LIST class header file (i.e. public_linked_list.h) and not in the LINKED_LIST class source file (i.e. public_linked_list.cpp).
 */
void LINKED_LIST::print(std::ostream &amp; output)
{
    int node_count = 0;
    NODE * p = head;
    NODE * q = head;
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.";
    output &lt;&lt; "\n&amp;head = " &lt;&lt; &amp;head &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.";
    output &lt;&lt; "\nsizeof(NODE) = " &lt;&lt; sizeof(NODE) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(NODE *) = " &lt;&lt; sizeof(NODE *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(LINKED_LIST) = " &lt;&lt; sizeof(LINKED_LIST) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nhead = " &lt;&lt; head &lt;&lt; ". // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).";
    output &lt;&lt; "\nhead -&gt; key = " &lt;&lt; head -&gt; key &lt;&lt; ". // The arrow operator returns the string type property named key of the NODE type variable which head points to.";
    output &lt;&lt; "\nhead -&gt; next = " &lt;&lt; head -&gt; next &lt;&lt; ". // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.";
    output &lt;&lt; "\nget_number_of_nodes_in_list() = " &lt;&lt; get_number_of_nodes_in_list() &lt;&lt; ".";
    output &lt;&lt; "\n// p is a pointer to a NODE type variable.";
    output &lt;&lt; "\nLINKED_LIST := {";
    while (q) 
    {
        p = q;
        output &lt;&lt; "\n\tNODE_" &lt;&lt; node_count &lt;&lt; " := {";
        output &lt;&lt; "\n\t\tp := " &lt;&lt; p &lt;&lt; ".";
        output &lt;&lt; "\n\t\tp -&gt; key = " &lt;&lt; p -&gt; key &lt;&lt; ".";
        output &lt;&lt; "\n\t\tp -&gt; next = " &lt;&lt; p -&gt; next &lt;&lt; ".";
        output &lt;&lt; "\n\t}.";
        q = p -&gt; next;
        node_count += 1;
    }
    output &lt;&lt; "\n}.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the LINKED_LIST class header file (i.e. public_linked_list.h).
 * 
 * The friend function is not a member of the LINKED_LIST class, 
 * but the friend function has access to the private and protected members 
 * of the LINKED_LIST class and not just to the public members of the LINKED_LIST class.
 * 
 * The friend keyword only prefaces the function prototype of this function 
 * (and the prototype of this function is declared in the LINKED_LIST class header file (i.e. public_linked_list.h)). 
 * 
 * The friend keyword does not preface the definition of this function
 * (and the definition of this function is specified in the LINKED_LIST class source file (i.e. public_linked_list.cpp)).
 * 
 * // overloaded print function example one
 * LINKED_LIST linked_list_0;
 * std::cout &lt;&lt; linked_list_0; // identical to linked_list_0.print();
 * 
 * // overloaded print function example two
 * std::ofstream file;
 * LINKED_LIST linked_list_1;
 * file &lt;&lt; linked_list_1; // identical to linked_list_1.print(file);
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, LINKED_LIST &amp; linked_list)
{
    linked_list.print(output);
    return output;
}

/**
 * The destructor method of the LINKED_LIST class de-allocates memory which was used to 
 * instantiate the LINKED_LIST object which is calling this function.
 * 
 * The destructor method of the LINKED_LIST class is automatically called when 
 * the program scope in which the caller LINKED_LIST object was instantiated terminates.
 */
LINKED_LIST::~LINKED_LIST()
{
    std::cout &lt;&lt; "\n\nDeleting the LINKED_LIST type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    delete head;
}
</pre>
<hr>
<p><strong>HASH_TABLE_CLASS_HEADER</strong></p>
<hr>
<p>The following header file contains the preprocessing directives and function prototypes of the HASH_TABLE class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.h</a></p>
<hr>
<pre>/**
 * file: hash_table.h
 * type: C++ (header file)
 * author: karbytes
 * date: 08_DECEMBER_2022
 * license: PUBLIC_DOMAIN
 */

/* preprocessing directives */
#ifndef HASH_TABLE_H // If hash_table.h has not already been linked to a source file (.cpp), 
#define HASH_TABLE_H // then link this header file to the source file(s) which include this header file.

/* preprocessing directives */
#include "public_linked_list.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the LINKED_LIST class.
#define MAXIMUM_N 100 // constant which represents maximum N value

/**
 * A variable whose data type is HASH_TABLE is a software object whose data attributes
 * consist of exactly one pointer-to-LINKED_LIST type variable named array 
 * and exactly one int type variable named N.
 * 
 * N stores a nonnegative integer value no larger than MAXIMUM_N.
 * 
 * array stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells
 * (and array is a pointer to the first element of an array comprised of N LINKED_LIST type elements).
 * 
 * When a HASH_TABLE type variable is declared, a dynamic LINKED_LIST type variable is created
 * and the memory address of that dynamic LINKED_LIST type variable is stored in a pointer-to-LINKED_LIST
 * type variable named array.
 * 
 * After a HASH_TABLE type variable is created and before that variable is deleted, 
 * NODE type elements can be inserted into the hash table array and
 * NODE type elements can be removed from the hash table array.
 * 
 * When a NODE is inserted into the hash table array, a hash function takes that NODE's key as 
 * a hash function input and then the hash function outputs a corresponding nonnegative integer
 * no larger than (N - 1) which represents the index of the hash table array where that
 * NODE will be inserted (and that NODE will be appended to the end of the LINKED_LIST which is stored at 
 * that particular array index).
 * 
 * After a HASH_TABLE type variable is created and before that variable is deleted,
 * that variable (i.e. object) can invoke a print function which prints a description
 * of the caller HASH_TABLE object.
 * 
 * When a HASH_TABLE variable is deleted, the pointer-to-LINKED_LIST type variable named array 
 * (which was assigned memory during program runtime rather than during program compilation time) 
 * and every head property of every LINKED_LIST type element of that array
 * is deleted.
 */
class HASH_TABLE
{
private:

    // array stores the memory address of the first element of an array of N LINKED_LIST type elements.
    LINKED_LIST * array; 

    // N stores a nonnegative integer value no larger than MAXIMUM_N.
    int N; 

    // The hash function returns an array index which corresponds with the input key value.
    int hash(std::string key); 

public:

    // The default constructor sets the length of the hash table array to 10 by default.
    HASH_TABLE(int hash_table_length = 10); 

    // The setter method appends the input NODE to the end of the LINKED_LIST located at array[hash(node -&gt; key)].
    void insert_node(NODE * node); 

    // The setter method removes all NODE type instances from the hash table array whose key values match the input key value.
    void remove_nodes_with_key(std::string key);

    // The getter method returns a singly-linked list of all NODE type instances in the hash table array whose key values match the input key value.
    LINKED_LIST get_nodes_with_key(std::string key);

    // The getter method returns the number of LINKED_LIST type values stored in the hash table array (and the value returned is N).
    int get_number_of_linked_lists_in_hash_table(); 

    // The getter method returns the total number of NODE type values stored in the hash table array (and the value returned is an integer which is equal to or larger than N).
    int get_number_of_nodes_in_hash_table(); 
    
    // The descriptor method prints a description of the caller HASH_TABLE object to the output stream (and the command line terminal is the default output stream parameter).
    void print(std::ostream &amp; output = std::cout); 
    
    // The descriptor method overloads the ostream operator to make it identical to calling the HASH_TABLE print function.
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, HASH_TABLE &amp; hash_table); 
    
    // The destructor de-allocates memory which was assigned to the caller HASH_TABLE object.
    ~HASH_TABLE(); 
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr>
<p><strong>HASH_TABLE_CLASS_SOURCE_CODE</strong></p>
<hr>
<p>The following source code defines the functions of the HASH_TABLE class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table.cpp</a></p>
<hr>
<pre>/**
 * file: hash_table.cpp
 * type: C++ (source file)
 * author: karbytes
 * date: 08_DECEMBER_2022
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the HASH_TABLE class.
#include "hash_table.h" 

/**
 * The hash function returns an array index which corresponds with the input key value.
 */
int HASH_TABLE::hash(std::string key)
{
    int value = 0, i = 0;
    for (i = 0; i &lt; key.length(); i += 1) value += int(key[i]);
    return value % N;
}

/**
 * The default constructor sets the length of the hash table array to 10 by default.
 * 
 * The function returns a HASH_TABLE type object.
 */
HASH_TABLE::HASH_TABLE(int hash_table_length)
{
    std::cout &lt;&lt; "\n\nCreating the HASH_TABLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    N = ((hash_table_length &lt; 1) || (hash_table_length &gt; MAXIMUM_N)) ? 10 : hash_table_length;
    array = new LINKED_LIST[N];
}

/**
 * The setter method appends the input NODE to the end of the LINKED_LIST located at array[hash(node -&gt; key)].
 */
void HASH_TABLE::insert_node(NODE * node)
{
    int index = hash(node -&gt; key);
    array[index].insert_node_at_end_of_list(node);
}

/**
 * The setter method removes all NODE type instances from the hash table array whose key values match the input key value.
 */
void HASH_TABLE::remove_nodes_with_key(std::string key)
{
    int index = hash(key);
    return array[index].remove_nodes_with_key(key);
}

/**
 * The getter method returns a singly-linked list of all NODE type instances in the hash table array whose key values match the input key value.
 * 
 * Set the next pointer value of the final NODE element in the returned LINKED_LIST to NULL.
 */
LINKED_LIST HASH_TABLE::get_nodes_with_key(std::string key)
{
    int index = hash(key);
    LINKED_LIST search_results;
    NODE * p = array[index].head;
    NODE * q = array[index].head;
    while (q)
    {
        if ((p -&gt; key == key) &amp;&amp; (p != array[index].head)) 
        {
            search_results.insert_node_at_end_of_list(p);
            p -&gt; next = NULL;
        }
        p = q;
        q = p -&gt; next;
    }

    return search_results;
}

/**
 * The getter method returns the number of LINKED_LIST type values stored in the hash table array (and the value returned is N).
 */
int HASH_TABLE::get_number_of_linked_lists_in_hash_table()
{
    return N;
}

/**
 * The getter method returns the total number of NODE type values stored in the hash table array (and the value returned is an integer which is equal to or larger than N).
 */
int HASH_TABLE::get_number_of_nodes_in_hash_table()
{
    int node_count = 0, i = 0;
    for (i = 0; i &lt; N; i += 1) node_count += array[i].get_number_of_nodes_in_list();
    return node_count;
}

/**
 * The descriptor method prints a description of the caller HASH_TABLE object to the output stream (and the command line terminal is the default output stream parameter).
 */
void HASH_TABLE::print(std::ostream &amp; output)
{
    int i = 0;
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.";
    output &lt;&lt; "\n&amp;array = " &lt;&lt; &amp;array &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.";
    output &lt;&lt; "\n&amp;N = " &lt;&lt; &amp;N &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(NODE) = " &lt;&lt; sizeof(NODE) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(NODE *) = " &lt;&lt; sizeof(NODE *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(LINKED_LIST) = " &lt;&lt; sizeof(LINKED_LIST) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(LINKED_LIST *) = " &lt;&lt; sizeof(LINKED_LIST *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(HASH_TABLE) = " &lt;&lt; sizeof(HASH_TABLE) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(HASH_TABLE) = " &lt;&lt; sizeof(HASH_TABLE *) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\narray = " &lt;&lt; array &lt;&lt; ". // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).";
    output &lt;&lt; "\nN = " &lt;&lt; N &lt;&lt; ". // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.";
    output &lt;&lt; "\nHASH_TABLE := {";
    for (i = 0; i &lt; N; i += 1)
    {
        output &lt;&lt; "\n\n############################################################";
        output &lt;&lt; "\narray[" &lt;&lt; i &lt;&lt; "] := {";
        output &lt;&lt; array[i];
        output &lt;&lt; "\n}.";
        output &lt;&lt; "\n############################################################";
    }
    output &lt;&lt; "\n}.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the HASH_TABLE class header file (i.e. hash_table.h).
 * 
 * The friend function is not a member of the HASH_TABLE class, 
 * but the friend function has access to the private and protected members 
 * of the HASH_TABLE class and not just to the public members of the HASH_TABLE class.
 * 
 * The friend keyword only prefaces the function prototype of this function 
 * (and the prototype of this function is declared in the HASH_TABLE class header file (i.e. hash_table.h)). 
 * 
 * The friend keyword does not preface the definition of this function
 * (and the definition of this function is specified in the HASH_TABLE class source file (i.e. hash_table.cpp)).
 * 
 * // overloaded print function example one
 * HASH_TABLE hash_table_0;
 * std::cout &lt;&lt; hash_table_0; // identical to hash_table_0.print();
 * 
 * // overloaded print function example two
 * std::ofstream file;
 * HASH_TABLE hash_table_1;
 * file &lt;&lt; hash_table_1; // identical to hash_table_1.print(file);
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, HASH_TABLE &amp; hash_table)
{
    hash_table.print(output);
    return output;
}

/**
 * The destructor method of the HASH_TABLE class de-allocates memory which was used to 
 * instantiate the HASH_TABLE object which is calling this function.
 * 
 * The destructor method of the HASH_TABLE class is automatically called when 
 * the program scope in which the caller HABLE_TABLE object was instantiated terminates.
 */
HASH_TABLE::~HASH_TABLE()
{
    std::cout &lt;&lt; "\n\nDeleting the HASH_TABLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    delete [] array;
}
</pre>
<hr>
<p><strong>PROGRAM_SOURCE_CODE</strong></p>
<hr>
<p>The following source code defines the client which implements the HASH_TABLE class. The client executes a series of unit tests which demonstrate how the HASH_TABLE class methods work.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver.cpp</a></p>
<hr>
<pre>/**
 * file: hash_table_driver.cpp
 * type: C++ (source file)
 * date: 08_DECEMBER_2022
 * author: karbytes
 * license: PUBLIC_DOMAIN 
 */

#include "hash_table.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the HASH_TABLE class.

/* function prototypes */
void unit_test_0(std::ostream &amp; output);
void unit_test_1(std::ostream &amp; output);
void unit_test_2(std::ostream &amp; output);
void unit_test_3(std::ostream &amp; output);
void unit_test_4(std::ostream &amp; output);
void unit_test_5(std::ostream &amp; output);

/**
 * Unit Test # 0: HASH_TABLE constructor, print method, and destructor.
 */
void unit_test_0(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 0: HASH_TABLE constructor, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table;";
    output &lt;&lt; "\nhash_table.print(output);";
    HASH_TABLE hash_table;
    hash_table.print(output);
}

/**
 * Unit Test # 1: HASH_TABLE constructor, insert method, print method, and destructor.
 */
void unit_test_1(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 1: HASH_TABLE constructor, insert method, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table;";
    output &lt;&lt; "\nNODE node;";
    output &lt;&lt; "\nnode.key = \"unit_test_1\";";
    output &lt;&lt; "\nnode.next = NULL;";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node);";
    output &lt;&lt; "\nhash_table.print(output);";
    HASH_TABLE hash_table;
    NODE node;
    node.key = "unit_test_1";
    node.next = NULL;
    hash_table.insert_node(&amp;node);
    hash_table.print(output);
}

/**
 * Unit Test # 2: HASH_TABLE constructor, insert method, print method, and destructor.
 */
void unit_test_2(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 2: HASH_TABLE constructor, insert method, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table;";
    output &lt;&lt; "\nNODE node_A = { key : \"node_A\", next : NULL };";
    output &lt;&lt; "\nNODE node_B = { key : \"node_B\", next : NULL };";
    output &lt;&lt; "\nNODE node_C = { key : \"node_C\", next : NULL };";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_A);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_B);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_C);";
    output &lt;&lt; "\noutput &lt;&lt; hash_table; // functionally identical to hash_table.print(output)";
    HASH_TABLE hash_table;
    NODE node_A = { key : "node_A", next : NULL };
    NODE node_B = { key : "node_B", next : NULL };
    NODE node_C = { key : "node_C", next : NULL };
    hash_table.insert_node(&amp;node_A);
    hash_table.insert_node(&amp;node_B);
    hash_table.insert_node(&amp;node_C);
    output &lt;&lt; hash_table; // functionally identical to hash_table.print(output);
}

/**
 * Unit Test # 3: HASH_TABLE constructor, insert method, number of linked lists method, number of node method, print method, and destructor.
 */
void unit_test_3(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 3: HASH_TABLE constructor, insert method, number of linked lists method, number of node method, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table = HASH_TABLE(5);";
    output &lt;&lt; "\nNODE node_A = { key : \"node_A\", next : NULL };";
    output &lt;&lt; "\nNODE node_B = { key : \"node_B\", next : NULL };";
    output &lt;&lt; "\nNODE node_C = { key : \"node_C\", next : NULL };";
    output &lt;&lt; "\nNODE node_AA = { key : \"node_AA\", next : NULL };";
    output &lt;&lt; "\nNODE node_BB = { key : \"node_BB\", next : NULL };";
    output &lt;&lt; "\nNODE node_CC = { key : \"node_CC\", next : NULL };";
    output &lt;&lt; "\nNODE node_Z = { key : \"node_Z\", next : NULL };";
    output &lt;&lt; "\nNODE node_666 = { key : \"node_666\", next : NULL };";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_A);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_B);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_C);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_AA);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_BB);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_CC);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_Z);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_666);";
    output &lt;&lt; "\noutput &lt;&lt; hash_table; // functionally identical to hash_table.print(output)";
    HASH_TABLE hash_table = HASH_TABLE(5);
    NODE node_A = { key : "node_A", next : NULL };
    NODE node_B = { key : "node_B", next : NULL };
    NODE node_C = { key : "node_C", next : NULL };
    NODE node_AA = { key : "node_AA", next : NULL };
    NODE node_BB = { key : "node_BB", next : NULL };
    NODE node_CC = { key : "node_CC", next : NULL };
    NODE node_Z = { key : "node_Z", next : NULL };
    NODE node_666 = { key : "node_666", next : NULL };
    hash_table.insert_node(&amp;node_A);
    hash_table.insert_node(&amp;node_B);
    hash_table.insert_node(&amp;node_C);
    hash_table.insert_node(&amp;node_AA);
    hash_table.insert_node(&amp;node_BB);
    hash_table.insert_node(&amp;node_CC);
    hash_table.insert_node(&amp;node_Z);
    hash_table.insert_node(&amp;node_666);
    output &lt;&lt; "\nhash_table.get_number_of_linked_lists_in_hash_table() = " &lt;&lt; hash_table.get_number_of_linked_lists_in_hash_table() &lt;&lt; ".";
    output &lt;&lt; "\nhash_table.get_number_of_nodes_in_hash_table()= " &lt;&lt; hash_table.get_number_of_nodes_in_hash_table() &lt;&lt; ".";
    output &lt;&lt; hash_table; // functionally identical to hash_table.print(output);
}

/**
 * Unit Test # 4: HASH_TABLE constructor, insert method, remove method, print method, and destructor.
 */
void unit_test_4(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 4: HASH_TABLE constructor, insert method, remove method, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table;";
    output &lt;&lt; "\nNODE node_0 = { key : \"XXX\", next : NULL };";
    output &lt;&lt; "\nNODE node_1 = { key : \"YYY\", next : NULL };";
    output &lt;&lt; "\nNODE node_2 = { key : \"ZZZ\", next : NULL };";
    output &lt;&lt; "\nNODE node_3 = { key : \"XXX\", next : NULL };";
    output &lt;&lt; "\nNODE node_4 = { key : \"YYY\", next : NULL };";
    output &lt;&lt; "\nNODE node_5 = { key : \"ZZZ\", next : NULL };";
    output &lt;&lt; "\nNODE node_6 = { key : \"XXX\", next : NULL };";
    output &lt;&lt; "\nNODE node_7 = { key : \"YYY\", next : NULL };";
    output &lt;&lt; "\nNODE node_8 = { key : \"ZZZ\", next : NULL };";
    output &lt;&lt; "\nNODE node_9 = { key : \"XXX\", next : NULL };";
    output &lt;&lt; "\nNODE node_10 = { key : \"YYY\", next : NULL };";
    output &lt;&lt; "\nNODE node_11 = { key : \"ZZZ\", next : NULL };";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_0);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_1);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_2);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_3);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_4);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_5);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_6);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_7);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_8);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_9);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_10);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_11);";
    output &lt;&lt; "\nhash_table.print(output);";
    output &lt;&lt; "\nhash_table.remove_nodes_with_key(\"XXX\");";
    output &lt;&lt; "\nhash_table.print(output);";
    HASH_TABLE hash_table;
    NODE node_0 = { key : "XXX", next : NULL };
    NODE node_1 = { key : "YYY", next : NULL };
    NODE node_2 = { key : "ZZZ", next : NULL };
    NODE node_3 = { key : "XXX", next : NULL };
    NODE node_4 = { key : "YYY", next : NULL };
    NODE node_5 = { key : "ZZZ", next : NULL };
    NODE node_6 = { key : "XXX", next : NULL };
    NODE node_7 = { key : "YYY", next : NULL };
    NODE node_8 = { key : "ZZZ", next : NULL };
    NODE node_9 = { key : "XXX", next : NULL };
    NODE node_10 = { key : "YYY", next : NULL };
    NODE node_11 = { key : "ZZZ", next : NULL };
    hash_table.insert_node(&amp;node_0);
    hash_table.insert_node(&amp;node_1);
    hash_table.insert_node(&amp;node_2);
    hash_table.insert_node(&amp;node_3);
    hash_table.insert_node(&amp;node_4);
    hash_table.insert_node(&amp;node_5);
    hash_table.insert_node(&amp;node_6);
    hash_table.insert_node(&amp;node_7);
    hash_table.insert_node(&amp;node_8);
    hash_table.insert_node(&amp;node_9);
    hash_table.insert_node(&amp;node_10);
    hash_table.insert_node(&amp;node_11);
    hash_table.print(output);
    hash_table.remove_nodes_with_key("XXX");
    hash_table.print(output);
}

/**
 * HASH_TABLE constructor, insert method, get nodes with key method, print method, and destructor.
 */
void unit_test_5(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n************************************************";
    output &lt;&lt; "\nUnit Test # 5: HASH_TABLE constructor, insert method, get nodes with key method, print method, and destructor.";
    output &lt;&lt; "\n************************************************";
    output &lt;&lt; "\nHASH_TABLE hash_table = HASH_TABLE(6);";
    output &lt;&lt; "\nNODE node_0 = { key : \"AAAA\", next : NULL };";
    output &lt;&lt; "\nNODE node_1 = { key : \"ABAB\", next : NULL };";
    output &lt;&lt; "\nNODE node_2 = { key : \"AABB\", next : NULL };";
    output &lt;&lt; "\nNODE node_3 = { key : \"CCCC\", next : NULL };";
    output &lt;&lt; "\nNODE node_4 = { key : \"ABAB\", next : NULL };";
    output &lt;&lt; "\nNODE node_5 = { key : \"CCCC\", next : NULL };";
    output &lt;&lt; "\nNODE node_6 = { key : \"BBBB\", next : NULL };";
    output &lt;&lt; "\nNODE node_7 = { key : \"ABAB\", next : NULL };";
    output &lt;&lt; "\nNODE node_8 = { key : \"AAAA\", next : NULL };";
    output &lt;&lt; "\nNODE node_9 = { key : \"CCCC\", next : NULL };";
    output &lt;&lt; "\nNODE node_10 = { key : \"DDDD\", next : NULL };";
    output &lt;&lt; "\nNODE node_11 = { key : \"AABB\", next : NULL };";
    output &lt;&lt; "\nNODE node_12 = { key : \"EEEE\", next : NULL };";
    output &lt;&lt; "\nNODE node_13 = { key : \"DDDD\", next : NULL };";
    output &lt;&lt; "\nNODE node_14 = { key : \"ABAB\", next : NULL };";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_0);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_1);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_2);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_3);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_4);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_5);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_6);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_7);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_8);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_9);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_10);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_11);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_12);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_13);";
    output &lt;&lt; "\nhash_table.insert_node(&amp;node_14);";
    output &lt;&lt; "\noutput &lt;&lt; hash_table; // functionally identical to hash_table.print(output)";
    output &lt;&lt; "\nLINKED_LIST search_results = hash_table.get_nodes_with_key(\"AAAA\");";
    output &lt;&lt; "\noutput &lt;&lt; search_results; // functionally identical to search_results.print(output);";
    HASH_TABLE hash_table = HASH_TABLE(6);
    NODE node_0 = { key : "AAAA", next : NULL };
    NODE node_1 = { key : "ABAB", next : NULL };
    NODE node_2 = { key : "AABB", next : NULL };
    NODE node_3 = { key : "CCCC", next : NULL };
    NODE node_4 = { key : "ABAB", next : NULL };
    NODE node_5 = { key : "CCCC", next : NULL };
    NODE node_6 = { key : "BBBB", next : NULL };
    NODE node_7 = { key : "ABAB", next : NULL };
    NODE node_8 = { key : "AAAA", next : NULL };
    NODE node_9 = { key : "CCCC", next : NULL };
    NODE node_10 = { key : "DDDD", next : NULL };
    NODE node_11 = { key : "AABB", next : NULL };
    NODE node_12 = { key : "EEEE", next : NULL };
    NODE node_13 = { key : "DDDD", next : NULL };
    NODE node_14 = { key : "ABAB", next : NULL };
    hash_table.insert_node(&amp;node_0);
    hash_table.insert_node(&amp;node_1);
    hash_table.insert_node(&amp;node_2);
    hash_table.insert_node(&amp;node_3);
    hash_table.insert_node(&amp;node_4);
    hash_table.insert_node(&amp;node_5);
    hash_table.insert_node(&amp;node_6);
    hash_table.insert_node(&amp;node_7);
    hash_table.insert_node(&amp;node_8);
    hash_table.insert_node(&amp;node_9);
    hash_table.insert_node(&amp;node_10);
    hash_table.insert_node(&amp;node_11);
    hash_table.insert_node(&amp;node_12);
    hash_table.insert_node(&amp;node_13);
    hash_table.insert_node(&amp;node_14);
    output &lt;&lt; hash_table; // functionally identical to hash_table.print(output);
    LINKED_LIST search_results = hash_table.get_nodes_with_key("AAAA");
    output &lt;&lt; search_results; // functionally identical to search_results.print(output);
}

/* program entry point */
int main()
{
    // Declare a file output stream object.
    std::ofstream file;

    /**
     * If hash_table_driver_output.txt does not already exist in the same directory as hash_table_driver.cpp, 
     * create a new file named hash_table_driver_output.txt.
     * 
     * Open the plain-text file named hash_table_driver_output.txt 
     * and set that file to be overwritten with program data.
     */
    file.open("hash_table_driver_output.txt");

    // Print an opening message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nStart Of Program";
    std::cout &lt;&lt; "\n--------------------------------";

    // Print an opening message to the file output stream.
    file &lt;&lt; "--------------------------------";
    file &lt;&lt; "\nStart Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Implement a series of unit tests which demonstrate the functionality of LINKED_LIST class variables.
    unit_test_0(std::cout);
    unit_test_0(file);
    unit_test_1(std::cout);
    unit_test_1(file);
    unit_test_2(std::cout);
    unit_test_2(file);
    unit_test_3(std::cout);
    unit_test_3(file);
    unit_test_4(std::cout);
    unit_test_4(file);
    unit_test_5(std::cout);
    unit_test_5(file);

    // Print a closing message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nEnd Of Program";
    std::cout &lt;&lt; "\n--------------------------------\n\n";

    // Print a closing message to the file output stream.
    file &lt;&lt; "\n\n--------------------------------";
    file &lt;&lt; "\nEnd Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Close the file output stream.
    file.close();

    // Exit the program.
    return 0;
}
</pre>
<hr>
<p><strong>SAMPLE_PROGRAM_OUTPUT</strong></p>
<hr>
<p>The text in the preformatted text box below was generated by one use case of the C++ program featured in this <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a> tutorial web page.</p>
<p>plain-text_file: <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver_output.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/karlina_object_2022_starter_pack/main/hash_table_driver_output.txt</a></p>
<hr>
<pre>--------------------------------
Start Of Program
--------------------------------

************************************************
Unit Test # 0: HASH_TABLE constructor, print method, and destructor.
************************************************
HASH_TABLE hash_table;
hash_table.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995f00. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995f00. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995f08. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee74b8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 10. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74b8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74b8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7600. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7600.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[6] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[7] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[8] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[9] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7500. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7500. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

************************************************
Unit Test # 1: HASH_TABLE constructor, insert method, print method, and destructor.
************************************************
HASH_TABLE hash_table;
NODE node;
node.key = "unit_test_1";
node.next = NULL;
hash_table.insert_node(&amp;node);
hash_table.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995ee0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995ee0. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995ee8. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee74b8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 10. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74b8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74b8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7600. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995ef0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7600.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_1 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = unit_test_1.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[6] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[7] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[8] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[9] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7500. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7500. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

************************************************
Unit Test # 2: HASH_TABLE constructor, insert method, print method, and destructor.
************************************************
HASH_TABLE hash_table;
NODE node_A = { key : "node_A", next : NULL };
NODE node_B = { key : "node_B", next : NULL };
NODE node_C = { key : "node_C", next : NULL };
hash_table.insert_node(&amp;node_A);
hash_table.insert_node(&amp;node_B);
hash_table.insert_node(&amp;node_C);
output &lt;&lt; hash_table; // functionally identical to hash_table.print(output)

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995e80. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995e80. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995e88. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee74b8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 10. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74b8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74b8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995e90. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995e90.
	}.
	NODE_1 := {
		p := 0x7ffc39995e90.
		p -&gt; key = node_A.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995ec0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995ec0.
	}.
	NODE_1 := {
		p := 0x7ffc39995ec0.
		p -&gt; key = node_B.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995ef0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_1 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = node_C.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[6] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[7] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[8] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7600. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7600.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[9] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7500. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7500. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

************************************************
Unit Test # 3: HASH_TABLE constructor, insert method, number of linked lists method, number of node method, print method, and destructor.
************************************************
HASH_TABLE hash_table = HASH_TABLE(5);
NODE node_A = { key : "node_A", next : NULL };
NODE node_B = { key : "node_B", next : NULL };
NODE node_C = { key : "node_C", next : NULL };
NODE node_AA = { key : "node_AA", next : NULL };
NODE node_BB = { key : "node_BB", next : NULL };
NODE node_CC = { key : "node_CC", next : NULL };
NODE node_Z = { key : "node_Z", next : NULL };
NODE node_666 = { key : "node_666", next : NULL };
hash_table.insert_node(&amp;node_A);
hash_table.insert_node(&amp;node_B);
hash_table.insert_node(&amp;node_C);
hash_table.insert_node(&amp;node_AA);
hash_table.insert_node(&amp;node_BB);
hash_table.insert_node(&amp;node_CC);
hash_table.insert_node(&amp;node_Z);
hash_table.insert_node(&amp;node_666);
output &lt;&lt; hash_table; // functionally identical to hash_table.print(output)
hash_table.get_number_of_linked_lists_in_hash_table() = 5.
hash_table.get_number_of_nodes_in_hash_table()= 13.

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995d90. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995d90. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995d98. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee76f8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 5. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee76f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee76f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7700. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7700. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995e90. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995e90.
	}.
	NODE_1 := {
		p := 0x7ffc39995e90.
		p -&gt; key = node_CC.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7708. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7708. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995da0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 4.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995da0.
	}.
	NODE_1 := {
		p := 0x7ffc39995da0.
		p -&gt; key = node_A.
		p -&gt; next = 0x7ffc39995e30.
	}.
	NODE_2 := {
		p := 0x7ffc39995e30.
		p -&gt; key = node_AA.
		p -&gt; next = 0x7ffc39995ec0.
	}.
	NODE_3 := {
		p := 0x7ffc39995ec0.
		p -&gt; key = node_Z.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7710. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7710. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995dd0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 2.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995dd0.
	}.
	NODE_1 := {
		p := 0x7ffc39995dd0.
		p -&gt; key = node_B.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7718. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7718. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995e00. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 4.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995e00.
	}.
	NODE_1 := {
		p := 0x7ffc39995e00.
		p -&gt; key = node_C.
		p -&gt; next = 0x7ffc39995e60.
	}.
	NODE_2 := {
		p := 0x7ffc39995e60.
		p -&gt; key = node_BB.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_3 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = node_666.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

************************************************
Unit Test # 4: HASH_TABLE constructor, insert method, remove method, print method, and destructor.
************************************************
HASH_TABLE hash_table;
NODE node_0 = { key : "XXX", next : NULL };
NODE node_1 = { key : "YYY", next : NULL };
NODE node_2 = { key : "ZZZ", next : NULL };
NODE node_3 = { key : "XXX", next : NULL };
NODE node_4 = { key : "YYY", next : NULL };
NODE node_5 = { key : "ZZZ", next : NULL };
NODE node_6 = { key : "XXX", next : NULL };
NODE node_7 = { key : "YYY", next : NULL };
NODE node_8 = { key : "ZZZ", next : NULL };
NODE node_9 = { key : "XXX", next : NULL };
NODE node_10 = { key : "YYY", next : NULL };
NODE node_11 = { key : "ZZZ", next : NULL };
hash_table.insert_node(&amp;node_0);
hash_table.insert_node(&amp;node_1);
hash_table.insert_node(&amp;node_2);
hash_table.insert_node(&amp;node_3);
hash_table.insert_node(&amp;node_4);
hash_table.insert_node(&amp;node_5);
hash_table.insert_node(&amp;node_6);
hash_table.insert_node(&amp;node_7);
hash_table.insert_node(&amp;node_8);
hash_table.insert_node(&amp;node_9);
hash_table.insert_node(&amp;node_10);
hash_table.insert_node(&amp;node_11);
hash_table.print(output);
hash_table.remove_nodes_with_key("XXX");
hash_table.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995cb0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995cb0. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995cb8. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee74b8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 10. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74b8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74b8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995d40. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995d40.
	}.
	NODE_1 := {
		p := 0x7ffc39995d40.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995dd0.
	}.
	NODE_2 := {
		p := 0x7ffc39995dd0.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995e60.
	}.
	NODE_3 := {
		p := 0x7ffc39995e60.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_4 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = ZZZ.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7600. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7600.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995ce0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995ce0.
	}.
	NODE_1 := {
		p := 0x7ffc39995ce0.
		p -&gt; key = XXX.
		p -&gt; next = 0x7ffc39995d70.
	}.
	NODE_2 := {
		p := 0x7ffc39995d70.
		p -&gt; key = XXX.
		p -&gt; next = 0x7ffc39995e00.
	}.
	NODE_3 := {
		p := 0x7ffc39995e00.
		p -&gt; key = XXX.
		p -&gt; next = 0x7ffc39995e90.
	}.
	NODE_4 := {
		p := 0x7ffc39995e90.
		p -&gt; key = XXX.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[6] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[7] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995d10. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995d10.
	}.
	NODE_1 := {
		p := 0x7ffc39995d10.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995da0.
	}.
	NODE_2 := {
		p := 0x7ffc39995da0.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995e30.
	}.
	NODE_3 := {
		p := 0x7ffc39995e30.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995ec0.
	}.
	NODE_4 := {
		p := 0x7ffc39995ec0.
		p -&gt; key = YYY.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[8] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[9] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7500. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7500. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995cb0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995cb0. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995cb8. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee74b8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 10. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74b8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74b8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7510. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995d40. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7510.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995d40.
	}.
	NODE_1 := {
		p := 0x7ffc39995d40.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995dd0.
	}.
	NODE_2 := {
		p := 0x7ffc39995dd0.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995e60.
	}.
	NODE_3 := {
		p := 0x7ffc39995e60.
		p -&gt; key = ZZZ.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_4 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = ZZZ.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7540. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7540.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74c8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74c8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7600. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7600.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74d8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74d8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[6] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74e8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74e8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[7] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f0. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995d10. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995d10.
	}.
	NODE_1 := {
		p := 0x7ffc39995d10.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995da0.
	}.
	NODE_2 := {
		p := 0x7ffc39995da0.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995e30.
	}.
	NODE_3 := {
		p := 0x7ffc39995e30.
		p -&gt; key = YYY.
		p -&gt; next = 0x7ffc39995ec0.
	}.
	NODE_4 := {
		p := 0x7ffc39995ec0.
		p -&gt; key = YYY.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[8] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee74f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee74f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[9] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7500. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7500. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

************************************************
Unit Test # 5: HASH_TABLE constructor, insert method, get nodes with key method, print method, and destructor.
************************************************
HASH_TABLE hash_table = HASH_TABLE(6);
NODE node_0 = { key : "AAAA", next : NULL };
NODE node_1 = { key : "ABAB", next : NULL };
NODE node_2 = { key : "AABB", next : NULL };
NODE node_3 = { key : "CCCC", next : NULL };
NODE node_4 = { key : "ABAB", next : NULL };
NODE node_5 = { key : "CCCC", next : NULL };
NODE node_6 = { key : "BBBB", next : NULL };
NODE node_7 = { key : "ABAB", next : NULL };
NODE node_8 = { key : "AAAA", next : NULL };
NODE node_9 = { key : "CCCC", next : NULL };
NODE node_10 = { key : "DDDD", next : NULL };
NODE node_11 = { key : "AABB", next : NULL };
NODE node_12 = { key : "EEEE", next : NULL };
NODE node_13 = { key : "DDDD", next : NULL };
NODE node_14 = { key : "ABAB", next : NULL };
hash_table.insert_node(&amp;node_0);
hash_table.insert_node(&amp;node_1);
hash_table.insert_node(&amp;node_2);
hash_table.insert_node(&amp;node_3);
hash_table.insert_node(&amp;node_4);
hash_table.insert_node(&amp;node_5);
hash_table.insert_node(&amp;node_6);
hash_table.insert_node(&amp;node_7);
hash_table.insert_node(&amp;node_8);
hash_table.insert_node(&amp;node_9);
hash_table.insert_node(&amp;node_10);
hash_table.insert_node(&amp;node_11);
hash_table.insert_node(&amp;node_12);
hash_table.insert_node(&amp;node_13);
hash_table.insert_node(&amp;node_14);
output &lt;&lt; hash_table; // functionally identical to hash_table.print(output)
LINKED_LIST search_results = hash_table.get_nodes_with_key("AAAA");
output &lt;&lt; search_results; // functionally identical to search_results.print(output);

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995c20. // The keyword named this is a pointer which stores the memory address of the first memory cell of a HASH_TABLE sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE object.
&amp;array = 0x7ffc39995c20. // The reference operation returns the memory address of the first memory cell of a pointer-to-LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named array.
&amp;N = 0x7ffc39995c28. // The reference operation returns the memory address of the first memory cell of a pointer-to-int sized chunk of contiguous memory cells which are allocated to the caller HASH_TABLE data attribute named N.
sizeof(int) = 4. // The sizeof() operation returns the number of bytes of memory which a int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 16. // The sizeof() operation returns the number of bytes of memory which a HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(HASH_TABLE) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-HASH_TABLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
array = 0x55baa4ee76f8. // array stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a LINKED_LIST type variable or else array stores NULL (and the value NULL is displayed as 0).
N = 6. // N stores the total number of LINKED_LIST types elements which are represented by the array property of the caller HASH_TABLE object.
HASH_TABLE := {

############################################################
array[0] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee76f8. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee76f8. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75a0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995d70. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 3.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75a0.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995d70.
	}.
	NODE_1 := {
		p := 0x7ffc39995d70.
		p -&gt; key = BBBB.
		p -&gt; next = 0x7ffc39995e90.
	}.
	NODE_2 := {
		p := 0x7ffc39995e90.
		p -&gt; key = EEEE.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[1] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7700. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7700. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee75d0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee75d0.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[2] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7708. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7708. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7690. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995c50. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 5.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7690.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995c50.
	}.
	NODE_1 := {
		p := 0x7ffc39995c50.
		p -&gt; key = AAAA.
		p -&gt; next = 0x7ffc39995dd0.
	}.
	NODE_2 := {
		p := 0x7ffc39995dd0.
		p -&gt; key = AAAA.
		p -&gt; next = 0x7ffc39995e30.
	}.
	NODE_3 := {
		p := 0x7ffc39995e30.
		p -&gt; key = DDDD.
		p -&gt; next = 0x7ffc39995ec0.
	}.
	NODE_4 := {
		p := 0x7ffc39995ec0.
		p -&gt; key = DDDD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[3] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7710. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7710. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7630. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7630.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[4] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7718. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7718. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7660. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995c80. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 10.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7660.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995c80.
	}.
	NODE_1 := {
		p := 0x7ffc39995c80.
		p -&gt; key = ABAB.
		p -&gt; next = 0x7ffc39995cb0.
	}.
	NODE_2 := {
		p := 0x7ffc39995cb0.
		p -&gt; key = AABB.
		p -&gt; next = 0x7ffc39995ce0.
	}.
	NODE_3 := {
		p := 0x7ffc39995ce0.
		p -&gt; key = CCCC.
		p -&gt; next = 0x7ffc39995d10.
	}.
	NODE_4 := {
		p := 0x7ffc39995d10.
		p -&gt; key = ABAB.
		p -&gt; next = 0x7ffc39995d40.
	}.
	NODE_5 := {
		p := 0x7ffc39995d40.
		p -&gt; key = CCCC.
		p -&gt; next = 0x7ffc39995da0.
	}.
	NODE_6 := {
		p := 0x7ffc39995da0.
		p -&gt; key = ABAB.
		p -&gt; next = 0x7ffc39995e00.
	}.
	NODE_7 := {
		p := 0x7ffc39995e00.
		p -&gt; key = CCCC.
		p -&gt; next = 0x7ffc39995e60.
	}.
	NODE_8 := {
		p := 0x7ffc39995e60.
		p -&gt; key = AABB.
		p -&gt; next = 0x7ffc39995ef0.
	}.
	NODE_9 := {
		p := 0x7ffc39995ef0.
		p -&gt; key = ABAB.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################

############################################################
array[5] := {

--------------------------------------------------------------------------------------------------
this = 0x55baa4ee7720. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x55baa4ee7720. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee7570. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 1.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee7570.
		p -&gt; key = HEAD.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------
}.
############################################################
}.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffc39995c18. // The keyword named this is a pointer which stores the memory address of the first memory cell of a LINKED_LIST sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST object.
&amp;head = 0x7ffc39995c18. // The reference operation returns the memory address of the first memory cell of a pointer-to-NODE sized chunk of contiguous memory cells which are allocated to the caller LINKED_LIST data attribute named head.
sizeof(NODE) = 40. // The sizeof() operation returns the number of bytes of memory which a NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(NODE *) = 8. // The sizeof() operation returns the number of bytes of memory which a pointer-to-NODE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(LINKED_LIST) = 8. // The sizeof() operation returns the number of bytes of memory which a LINKED_LIST type variable occupies. (Each memory cell has a data capacity of 1 byte).
head = 0x55baa4ee76c0. // head stores either the first memory cell of a contiguous chunk of memory cells which are allocated to a NODE type variable or else head stores NULL (and the value NULL is displayed as 0).
head -&gt; key = HEAD. // The arrow operator returns the string type property named key of the NODE type variable which head points to.
head -&gt; next = 0x7ffc39995c50. // The arrow operator returns the pointer-to-NODE type property named next of the NODE type variable which head points to.
get_number_of_nodes_in_list() = 3.
// p is a pointer to a NODE type variable.
LINKED_LIST := {
	NODE_0 := {
		p := 0x55baa4ee76c0.
		p -&gt; key = HEAD.
		p -&gt; next = 0x7ffc39995c50.
	}.
	NODE_1 := {
		p := 0x7ffc39995c50.
		p -&gt; key = AAAA.
		p -&gt; next = 0x7ffc39995dd0.
	}.
	NODE_2 := {
		p := 0x7ffc39995dd0.
		p -&gt; key = AAAA.
		p -&gt; next = 0.
	}.
}.
--------------------------------------------------------------------------------------------------

--------------------------------
End Of Program
--------------------------------
</pre>
<hr>
<p>This web page was last updated on 08_DECEMBER_2022. The content displayed on this web page is licensed as <a style="background:#000000;color:#ff9000" href="https://karlinaobject.wordpress.com/public_domain/" target="_blank" rel="noopener">PUBLIC_DOMAIN</a> intellectual property.</p>
<hr>
